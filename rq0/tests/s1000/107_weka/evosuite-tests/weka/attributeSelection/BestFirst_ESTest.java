/*
 * This file was automatically generated by EvoSuite
 * Tue Aug 07 13:57:43 GMT 2018
 */

package weka.attributeSelection;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.ArrayList;
import java.util.BitSet;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import weka.attributeSelection.BestFirst;
import weka.attributeSelection.CfsSubsetEval;
import weka.attributeSelection.OneRAttributeEval;
import weka.classifiers.functions.SMOreg;
import weka.classifiers.meta.AttributeSelectedClassifier;
import weka.core.Attribute;
import weka.core.Instances;
import weka.core.SelectedTag;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class BestFirst_ESTest extends BestFirst_ESTest_scaffolding {

  /**
  //Test case number: 0
  /*Coverage entropy=1.7917594692280547
  */
  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      BestFirst.LinkedList2 bestFirst_LinkedList2_0 = bestFirst0.new LinkedList2(1802);
      Object object0 = new Object();
      bestFirst_LinkedList2_0.addToList(bestFirst0.TAGS_SELECTION, 1802);
      try { 
        bestFirst_LinkedList2_0.getLinkAt(1802);
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // index out of range (getLinkAt)
         //
         verifyException("weka.attributeSelection.BestFirst$LinkedList2", e);
      }
  }

  /**
  //Test case number: 1
  /*Coverage entropy=1.7478680974667573
  */
  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      int int0 = 0;
      BestFirst.LinkedList2 bestFirst_LinkedList2_0 = bestFirst0.new LinkedList2(0);
      bestFirst_LinkedList2_0.addToList(bestFirst0.TAGS_SELECTION, 0);
      try { 
        bestFirst_LinkedList2_0.getLinkAt((-381));
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // index out of range (getLinkAt)
         //
         verifyException("weka.attributeSelection.BestFirst$LinkedList2", e);
      }
  }

  /**
  //Test case number: 2
  /*Coverage entropy=1.3862943611198906
  */
  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      BestFirst.Link2 bestFirst_Link2_0 = bestFirst0.new Link2(bestFirst0.TAGS_SELECTION, 0);
      bestFirst_Link2_0.getRevision();
      CfsSubsetEval cfsSubsetEval0 = new CfsSubsetEval();
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
  }

  /**
  //Test case number: 3
  /*Coverage entropy=1.0986122886681096
  */
  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      String string0 = bestFirst0.getRevision();
      assertEquals("8034", string0);
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals(1, bestFirst0.getLookupCacheSize());
  }

  /**
  //Test case number: 4
  /*Coverage entropy=1.0986122886681096
  */
  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      String string0 = bestFirst0.directionTipText();
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the direction of the search.", string0);
      assertEquals(1, bestFirst0.getLookupCacheSize());
  }

  /**
  //Test case number: 5
  /*Coverage entropy=1.0986122886681096
  */
  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      String string0 = bestFirst0.searchTerminationTipText();
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the amount of backtracking. Specify the number of ", string0);
      assertEquals(1, bestFirst0.getLookupCacheSize());
  }

  /**
  //Test case number: 6
  /*Coverage entropy=1.6094379124341005
  */
  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      bestFirst0.listOptions();
      BestFirst.LinkedList2 bestFirst_LinkedList2_0 = bestFirst0.new LinkedList2(10);
      try { 
        bestFirst_LinkedList2_0.removeLinkAt(10);
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // index out of range (removeLinkAt)
         //
         verifyException("weka.attributeSelection.BestFirst$LinkedList2", e);
      }
  }

  /**
  //Test case number: 7
  /*Coverage entropy=1.3862943611198906
  */
  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      BestFirst.LinkedList2 bestFirst_LinkedList2_0 = bestFirst0.new LinkedList2(1802);
      try { 
        bestFirst_LinkedList2_0.getLinkAt(1802);
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // List is empty (getLinkAt)
         //
         verifyException("weka.attributeSelection.BestFirst$LinkedList2", e);
      }
  }

  /**
  //Test case number: 8
  /*Coverage entropy=1.3862943611198906
  */
  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      SelectedTag selectedTag0 = bestFirst0.getDirection();
      assertEquals("1", selectedTag0.toString());
      
      String string0 = bestFirst0.toString();
      assertEquals("\tBest first.\n\tStart set: no attributes\n\tSearch direction: forward\n\tStale search after 5 node expansions\n\tTotal number of subsets evaluated: 0\n\tMerit of best subset found:    0    \n", string0);
      assertEquals(1, bestFirst0.getLookupCacheSize());
  }

  /**
  //Test case number: 9
  /*Coverage entropy=1.0986122886681096
  */
  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      bestFirst0.getSearchTermination();
      byte[] byteArray0 = new byte[8];
      byteArray0[3] = (byte) (-9);
      byteArray0[4] = (byte) (-9);
      byteArray0[5] = (byte)18;
      BitSet bitSet0 = BitSet.valueOf(byteArray0);
      assertFalse(bitSet0.isEmpty());
  }

  /**
  //Test case number: 10
  /*Coverage entropy=2.3034884952192693
  */
  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      CfsSubsetEval cfsSubsetEval0 = new CfsSubsetEval();
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      Attribute attribute0 = new Attribute("zk");
      arrayList0.add(attribute0);
      Instances instances0 = new Instances("numeric", arrayList0, 4);
      int[] intArray0 = bestFirst0.search(cfsSubsetEval0, instances0);
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals(0, intArray0.length);
  }

  /**
  //Test case number: 11
  /*Coverage entropy=1.0986122886681096
  */
  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      int int0 = bestFirst0.getLookupCacheSize();
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals(1, int0);
  }

  /**
  //Test case number: 12
  /*Coverage entropy=1.7917594692280547
  */
  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      bestFirst0.setStartSet("P");
      String[] stringArray0 = bestFirst0.getOptions();
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals(6, stringArray0.length);
  }

  /**
  //Test case number: 13
  /*Coverage entropy=1.3862943611198906
  */
  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      BitSet bitSet0 = new BitSet();
      bestFirst0.printGroup(bitSet0, 137);
      String[] stringArray0 = new String[0];
      bestFirst0.setOptions(stringArray0);
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals(1, bestFirst0.getLookupCacheSize());
  }

  /**
  //Test case number: 14
  /*Coverage entropy=1.0986122886681096
  */
  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      bestFirst0.setLookupCacheSize(545);
      assertEquals(545, bestFirst0.getLookupCacheSize());
  }

  /**
  //Test case number: 15
  /*Coverage entropy=1.242453324894
  */
  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      
      try { 
        bestFirst0.setSearchTermination((-1250));
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // Value of -N must be > 0.
         //
         verifyException("weka.attributeSelection.BestFirst", e);
      }
  }

  /**
  //Test case number: 16
  /*Coverage entropy=1.3862943611198906
  */
  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      
      BestFirst.Link2 bestFirst_Link2_0 = bestFirst0.new Link2(bestFirst0.TAGS_SELECTION, 0.0);
      assertNotNull(bestFirst_Link2_0);
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      
      String string0 = bestFirst_Link2_0.toString();
      assertNotNull(string0);
      assertEquals("Node: [Lweka.core.Tag;@0000000004  0.0", string0);
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
  }

  /**
  //Test case number: 17
  /*Coverage entropy=1.3862943611198906
  */
  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      
      String[] stringArray0 = new String[0];
      bestFirst0.setOptions(stringArray0);
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(0, stringArray0.length);
  }

  /**
  //Test case number: 18
  /*Coverage entropy=1.945910149055313
  */
  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      
      String[] stringArray0 = bestFirst0.getOptions();
      assertNotNull(stringArray0);
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals(6, stringArray0.length);
      
      bestFirst0.setOptions(stringArray0);
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals(6, stringArray0.length);
  }

  /**
  //Test case number: 19
  /*Coverage entropy=1.0986122886681096
  */
  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      
      SMOreg sMOreg0 = new SMOreg();
      assertNotNull(sMOreg0);
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      
      SelectedTag selectedTag0 = sMOreg0.getFilterType();
      assertNotNull(selectedTag0);
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertEquals("0", selectedTag0.toString());
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      
      bestFirst0.setDirection(selectedTag0);
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertEquals("0", selectedTag0.toString());
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
  }

  /**
  //Test case number: 20
  /*Coverage entropy=2.2397458666084575
  */
  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      
      bestFirst0.m_debug = true;
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      
      CfsSubsetEval cfsSubsetEval0 = new CfsSubsetEval();
      assertNotNull(cfsSubsetEval0);
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      
      Attribute attribute0 = new Attribute("/W;6:aqS0<");
      assertNotNull(attribute0);
      assertTrue(attribute0.isRegular());
      assertTrue(attribute0.isAveragable());
      assertFalse(attribute0.isNominal());
      assertTrue(attribute0.hasZeropoint());
      assertEquals("", attribute0.getDateFormat());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isNumeric());
      assertEquals("/W;6:aqS0<", attribute0.name());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals(1, attribute0.ordering());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.isString());
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0, attribute0.type());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(1, Attribute.NOMINAL);
      
      boolean boolean0 = arrayList0.add(attribute0);
      assertTrue(boolean0);
      assertTrue(arrayList0.contains(attribute0));
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertTrue(attribute0.isRegular());
      assertTrue(attribute0.isAveragable());
      assertFalse(attribute0.isNominal());
      assertTrue(attribute0.hasZeropoint());
      assertEquals("", attribute0.getDateFormat());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isNumeric());
      assertEquals("/W;6:aqS0<", attribute0.name());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals(1, attribute0.ordering());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.isString());
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0, attribute0.type());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(1, Attribute.NOMINAL);
      
      Instances instances0 = new Instances("", arrayList0, 1);
      assertNotNull(instances0);
      assertTrue(arrayList0.contains(attribute0));
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals("", instances0.relationName());
      
      int[] intArray0 = bestFirst0.search(cfsSubsetEval0, instances0);
      assertNotNull(intArray0);
      assertArrayEquals(new int[] {}, intArray0);
      assertTrue(arrayList0.contains(attribute0));
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals("", instances0.relationName());
      assertEquals(0, intArray0.length);
  }

  /**
  //Test case number: 21
  /*Coverage entropy=1.3862943611198906
  */
  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      
      CfsSubsetEval cfsSubsetEval0 = new CfsSubsetEval();
      assertNotNull(cfsSubsetEval0);
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      
      BestFirst.LinkedList2 bestFirst_LinkedList2_0 = bestFirst0.new LinkedList2(3);
      assertNotNull(bestFirst_LinkedList2_0);
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertTrue(bestFirst_LinkedList2_0.isEmpty());
      assertEquals(0, bestFirst_LinkedList2_0.size());
      
      String string0 = bestFirst_LinkedList2_0.getRevision();
      assertNotNull(string0);
      assertEquals("8034", string0);
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertTrue(bestFirst_LinkedList2_0.isEmpty());
      assertEquals(0, bestFirst_LinkedList2_0.size());
  }

  /**
  //Test case number: 22
  /*Coverage entropy=1.0986122886681096
  */
  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      
      String string0 = bestFirst0.startSetTipText();
      assertNotNull(string0);
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", string0);
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
  }

  /**
  //Test case number: 23
  /*Coverage entropy=1.0986122886681096
  */
  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      
      String string0 = bestFirst0.lookupCacheSizeTipText();
      assertNotNull(string0);
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", string0);
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
  }

  /**
  //Test case number: 24
  /*Coverage entropy=1.0986122886681096
  */
  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      
      String string0 = bestFirst0.globalInfo();
      assertNotNull(string0);
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", string0);
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
  }

  /**
  //Test case number: 25
  /*Coverage entropy=1.3862943611198906
  */
  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      
      BestFirst.LinkedList2 bestFirst_LinkedList2_0 = bestFirst0.new LinkedList2(0);
      assertNotNull(bestFirst_LinkedList2_0);
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(0, bestFirst_LinkedList2_0.size());
      assertTrue(bestFirst_LinkedList2_0.isEmpty());
      
      try { 
        bestFirst_LinkedList2_0.removeLinkAt((-1446));
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // index out of range (removeLinkAt)
         //
         verifyException("weka.attributeSelection.BestFirst$LinkedList2", e);
      }
  }

  /**
  //Test case number: 26
  /*Coverage entropy=1.3321790402101223
  */
  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      
      bestFirst0.setLookupCacheSize((-1353));
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      
      String[] stringArray0 = new String[0];
      bestFirst0.setOptions(stringArray0);
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals(0, stringArray0.length);
  }

  /**
  //Test case number: 27
  /*Coverage entropy=1.0986122886681096
  */
  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      
      OneRAttributeEval oneRAttributeEval0 = new OneRAttributeEval();
      assertNotNull(oneRAttributeEval0);
      assertEquals(6, oneRAttributeEval0.getMinimumBucketSize());
      assertEquals("The minimum number of objects in a bucket (passed to OneR).", oneRAttributeEval0.minimumBucketSizeTipText());
      assertFalse(oneRAttributeEval0.getEvalUsingTrainingData());
      assertEquals("Set the number of folds for cross validation.", oneRAttributeEval0.foldsTipText());
      assertEquals("OneRAttributeEval :\n\nEvaluates the worth of an attribute by using the OneR classifier.\n", oneRAttributeEval0.globalInfo());
      assertEquals(10, oneRAttributeEval0.getFolds());
      assertEquals(1, oneRAttributeEval0.getSeed());
      assertEquals("Use the training data to evaluate attributes rather than cross validation.", oneRAttributeEval0.evalUsingTrainingDataTipText());
      assertEquals("Set the seed for use in cross validation.", oneRAttributeEval0.seedTipText());
      
      try { 
        bestFirst0.search(oneRAttributeEval0, (Instances) null);
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // weka.attributeSelection.OneRAttributeEval is not a Subset evaluator!
         //
         verifyException("weka.attributeSelection.BestFirst", e);
      }
  }

  /**
  //Test case number: 28
  /*Coverage entropy=0.9495936677167384
  */
  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      
      BestFirst.LinkedList2 bestFirst_LinkedList2_0 = bestFirst0.new LinkedList2((-1136));
      assertNotNull(bestFirst_LinkedList2_0);
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(0, bestFirst_LinkedList2_0.size());
      assertTrue(bestFirst_LinkedList2_0.isEmpty());
      
      bestFirst_LinkedList2_0.addToList(bestFirst0.TAGS_SELECTION, (-1136));
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst_LinkedList2_0.size());
      assertFalse(bestFirst_LinkedList2_0.isEmpty());
      
      bestFirst_LinkedList2_0.addToList(bestFirst0.TAGS_SELECTION, 1274);
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(2, bestFirst_LinkedList2_0.size());
      assertFalse(bestFirst_LinkedList2_0.isEmpty());
      
      bestFirst_LinkedList2_0.addToList(bestFirst0.TAGS_SELECTION, 1274);
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertFalse(bestFirst_LinkedList2_0.isEmpty());
      assertEquals(3, bestFirst_LinkedList2_0.size());
  }

  /**
  //Test case number: 29
  /*Coverage entropy=2.1639556568820564
  */
  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      
      bestFirst0.setStartSet("Ac;\u0007^cw:W$v*R{");
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      
      String[] stringArray0 = bestFirst0.getOptions();
      assertNotNull(stringArray0);
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals(6, stringArray0.length);
      
      bestFirst0.setOptions(stringArray0);
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals(6, stringArray0.length);
  }

  /**
  //Test case number: 30
  /*Coverage entropy=1.242453324894
  */
  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      
      bestFirst0.m_searchDirection = 1093;
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      
      BestFirst.LinkedList2 bestFirst_LinkedList2_0 = bestFirst0.new LinkedList2(1093);
      assertNotNull(bestFirst_LinkedList2_0);
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertTrue(bestFirst_LinkedList2_0.isEmpty());
      assertEquals(0, bestFirst_LinkedList2_0.size());
      
      String string0 = bestFirst0.toString();
      assertNotNull(string0);
      assertEquals("\tBest first.\n\tStart set: no attributes\n\tSearch direction: bi-directional\n\tStale search after 5 node expansions\n\tTotal number of subsets evaluated: 0\n\tMerit of best subset found:    0    \n", string0);
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
  }

  /**
  //Test case number: 31
  /*Coverage entropy=1.6094379124341003
  */
  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      
      BestFirst.LinkedList2 bestFirst_LinkedList2_0 = bestFirst0.new LinkedList2(1);
      assertNotNull(bestFirst_LinkedList2_0);
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertTrue(bestFirst_LinkedList2_0.isEmpty());
      assertEquals(0, bestFirst_LinkedList2_0.size());
      
      bestFirst_LinkedList2_0.addToList(bestFirst0.TAGS_SELECTION, (-389.0));
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertFalse(bestFirst_LinkedList2_0.isEmpty());
      assertEquals(1, bestFirst_LinkedList2_0.size());
      
      bestFirst_LinkedList2_0.addToList(bestFirst0.TAGS_SELECTION, 4061);
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertFalse(bestFirst_LinkedList2_0.isEmpty());
      assertEquals(1, bestFirst_LinkedList2_0.size());
  }

  /**
  //Test case number: 32
  /*Coverage entropy=1.4735023850806486
  */
  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      
      CfsSubsetEval cfsSubsetEval0 = new CfsSubsetEval();
      assertNotNull(cfsSubsetEval0);
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      
      Attribute attribute0 = new Attribute("backward");
      assertNotNull(attribute0);
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(attribute0.isDate());
      assertEquals(1, attribute0.ordering());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0, attribute0.type());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals("backward", attribute0.name());
      assertTrue(attribute0.isRegular());
      assertEquals(0, attribute0.numValues());
      assertEquals("", attribute0.getDateFormat());
      assertTrue(attribute0.hasZeropoint());
      assertTrue(attribute0.isAveragable());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertTrue(attribute0.isNumeric());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isRelationValued());
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.STRING);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      
      BestFirst.LinkedList2 bestFirst_LinkedList2_0 = bestFirst0.new LinkedList2(2);
      assertNotNull(bestFirst_LinkedList2_0);
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals(0, bestFirst_LinkedList2_0.size());
      assertTrue(bestFirst_LinkedList2_0.isEmpty());
      
      bestFirst_LinkedList2_0.addToList(bestFirst0.TAGS_SELECTION, 2);
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertFalse(bestFirst_LinkedList2_0.isEmpty());
      assertEquals(1, bestFirst_LinkedList2_0.size());
      
      bestFirst_LinkedList2_0.addToList(bestFirst0.TAGS_SELECTION, 0);
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertFalse(bestFirst_LinkedList2_0.isEmpty());
      assertEquals(2, bestFirst_LinkedList2_0.size());
      
      bestFirst_LinkedList2_0.addToList(bestFirst0.TAGS_SELECTION, 1);
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertFalse(bestFirst_LinkedList2_0.isEmpty());
      assertEquals(2, bestFirst_LinkedList2_0.size());
  }

  /**
  //Test case number: 33
  /*Coverage entropy=1.3862943611198906
  */
  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      
      int[] intArray0 = new int[8];
      bestFirst0.m_starting = intArray0;
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      
      String string0 = bestFirst0.toString();
      assertNotNull(string0);
      assertEquals("\tBest first.\n\tStart set: 1,1,1,1,1,1,1,1\n\tSearch direction: forward\n\tStale search after 5 node expansions\n\tTotal number of subsets evaluated: 0\n\tMerit of best subset found:    0    \n", string0);
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
  }

  /**
  //Test case number: 34
  /*Coverage entropy=2.245171589411516
  */
  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      
      CfsSubsetEval cfsSubsetEval0 = new CfsSubsetEval();
      assertNotNull(cfsSubsetEval0);
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      
      int[] intArray0 = new int[11];
      bestFirst0.m_starting = intArray0;
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      
      Instances instances0 = new Instances("Bi-1irectional", arrayList0, 0);
      assertNotNull(instances0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertEquals("Bi-1irectional", instances0.relationName());
      
      int[] intArray1 = bestFirst0.search(cfsSubsetEval0, instances0);
      assertNotNull(intArray1);
      assertNotSame(intArray1, intArray0);
      assertArrayEquals(new int[] {}, intArray1);
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertEquals("Bi-1irectional", instances0.relationName());
      assertEquals(0, intArray1.length);
      assertFalse(intArray1.equals((Object)intArray0));
  }

  /**
  //Test case number: 35
  /*Coverage entropy=1.0317671113505356
  */
  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      
      int[] intArray0 = new int[2];
      bestFirst0.m_hasClass = true;
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      
      bestFirst0.m_starting = intArray0;
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      
      String string0 = bestFirst0.toString();
      assertNotNull(string0);
      assertEquals("\tBest first.\n\tStart set: 1,1\n\tSearch direction: forward\n\tStale search after 5 node expansions\n\tTotal number of subsets evaluated: 0\n\tMerit of best subset found:    0    \n", string0);
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
  }

  /**
  //Test case number: 36
  /*Coverage entropy=2.0870852946037424
  */
  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      
      CfsSubsetEval cfsSubsetEval0 = new CfsSubsetEval();
      assertNotNull(cfsSubsetEval0);
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      
      Attribute attribute0 = new Attribute("/W;6:aqS0<");
      assertNotNull(attribute0);
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(1, attribute0.ordering());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertEquals("/W;6:aqS0<", attribute0.name());
      assertFalse(attribute0.isString());
      assertEquals(0, attribute0.type());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isRelationValued());
      assertTrue(attribute0.isNumeric());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isDate());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.hasZeropoint());
      assertTrue(attribute0.isRegular());
      assertTrue(attribute0.isAveragable());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals("", attribute0.getDateFormat());
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      
      boolean boolean0 = arrayList0.add(attribute0);
      assertTrue(boolean0);
      assertTrue(arrayList0.contains(attribute0));
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(1, attribute0.ordering());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertEquals("/W;6:aqS0<", attribute0.name());
      assertFalse(attribute0.isString());
      assertEquals(0, attribute0.type());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isRelationValued());
      assertTrue(attribute0.isNumeric());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isDate());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.hasZeropoint());
      assertTrue(attribute0.isRegular());
      assertTrue(attribute0.isAveragable());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals("", attribute0.getDateFormat());
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      
      bestFirst0.m_searchDirection = 2;
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      
      Instances instances0 = new Instances("string", arrayList0, 3);
      assertNotNull(instances0);
      assertTrue(arrayList0.contains(attribute0));
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertEquals(1, instances0.numAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals("string", instances0.relationName());
      
      int[] intArray0 = bestFirst0.search(cfsSubsetEval0, instances0);
      assertNotNull(intArray0);
      assertArrayEquals(new int[] {}, intArray0);
      assertTrue(arrayList0.contains(attribute0));
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertEquals(1, instances0.numAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals("string", instances0.relationName());
      assertEquals(0, intArray0.length);
  }

  /**
  //Test case number: 37
  /*Coverage entropy=1.7677103011358954
  */
  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      
      CfsSubsetEval cfsSubsetEval0 = new CfsSubsetEval();
      assertNotNull(cfsSubsetEval0);
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      
      Attribute attribute0 = new Attribute("zk");
      assertNotNull(attribute0);
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(1, attribute0.ordering());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertTrue(attribute0.isNumeric());
      assertEquals("", attribute0.getDateFormat());
      assertTrue(attribute0.isAveragable());
      assertEquals("zk", attribute0.name());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isRelationValued());
      assertTrue(attribute0.hasZeropoint());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertEquals(0, attribute0.type());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isRegular());
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(3, Attribute.DATE);
      
      boolean boolean0 = arrayList0.add(attribute0);
      assertTrue(boolean0);
      assertTrue(arrayList0.contains(attribute0));
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(1, attribute0.ordering());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertTrue(attribute0.isNumeric());
      assertEquals("", attribute0.getDateFormat());
      assertTrue(attribute0.isAveragable());
      assertEquals("zk", attribute0.name());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isRelationValued());
      assertTrue(attribute0.hasZeropoint());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertEquals(0, attribute0.type());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isRegular());
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(3, Attribute.DATE);
      
      Instances instances0 = new Instances("numeric", arrayList0, 4);
      assertNotNull(instances0);
      assertTrue(arrayList0.contains(attribute0));
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals("numeric", instances0.relationName());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(1, instances0.numAttributes());
      
      instances0.setClass(attribute0);
      assertTrue(arrayList0.contains(attribute0));
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(1, attribute0.ordering());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertTrue(attribute0.isNumeric());
      assertEquals("", attribute0.getDateFormat());
      assertTrue(attribute0.isAveragable());
      assertEquals("zk", attribute0.name());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isRelationValued());
      assertTrue(attribute0.hasZeropoint());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertEquals(0, attribute0.type());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isRegular());
      assertEquals(0, instances0.classIndex());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertEquals("numeric", instances0.relationName());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(1, instances0.numClasses());
      assertEquals(1, instances0.numAttributes());
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(3, Attribute.DATE);
      
      int[] intArray0 = bestFirst0.search(cfsSubsetEval0, instances0);
      assertNotNull(intArray0);
      assertArrayEquals(new int[] {}, intArray0);
      assertTrue(arrayList0.contains(attribute0));
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertEquals(0, instances0.classIndex());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertEquals("numeric", instances0.relationName());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(1, instances0.numClasses());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0, intArray0.length);
  }

  /**
  //Test case number: 38
  /*Coverage entropy=1.3893804876429847
  */
  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      
      CfsSubsetEval cfsSubsetEval0 = new CfsSubsetEval();
      assertNotNull(cfsSubsetEval0);
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      
      Attribute attribute0 = new Attribute("/W;6:aqS0<");
      assertNotNull(attribute0);
      assertTrue(attribute0.isNumeric());
      assertEquals("", attribute0.getDateFormat());
      assertFalse(attribute0.isNominal());
      assertEquals("/W;6:aqS0<", attribute0.name());
      assertTrue(attribute0.isRegular());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(0, attribute0.type());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertEquals(0, attribute0.numValues());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.isString());
      assertTrue(attribute0.isAveragable());
      assertEquals(1, attribute0.ordering());
      assertTrue(attribute0.hasZeropoint());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.STRING);
      
      boolean boolean0 = arrayList0.add(attribute0);
      assertTrue(boolean0);
      assertTrue(arrayList0.contains(attribute0));
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertTrue(attribute0.isNumeric());
      assertEquals("", attribute0.getDateFormat());
      assertFalse(attribute0.isNominal());
      assertEquals("/W;6:aqS0<", attribute0.name());
      assertTrue(attribute0.isRegular());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(0, attribute0.type());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertEquals(0, attribute0.numValues());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.isString());
      assertTrue(attribute0.isAveragable());
      assertEquals(1, attribute0.ordering());
      assertTrue(attribute0.hasZeropoint());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.STRING);
      
      bestFirst0.m_searchDirection = 0;
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      
      Instances instances0 = new Instances("string", arrayList0, 3);
      assertNotNull(instances0);
      assertTrue(arrayList0.contains(attribute0));
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals("string", instances0.relationName());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-1), instances0.classIndex());
      
      int[] intArray0 = bestFirst0.search(cfsSubsetEval0, instances0);
      assertNotNull(intArray0);
      assertArrayEquals(new int[] {0}, intArray0);
      assertTrue(arrayList0.contains(attribute0));
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals("string", instances0.relationName());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals(1, intArray0.length);
      
      int[] intArray1 = bestFirst0.search(cfsSubsetEval0, instances0);
      assertNotNull(intArray1);
      assertNotSame(intArray1, intArray0);
      assertArrayEquals(new int[] {}, intArray1);
      assertTrue(arrayList0.contains(attribute0));
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals("string", instances0.relationName());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, intArray1.length);
      assertFalse(intArray1.equals((Object)intArray0));
  }

  /**
  //Test case number: 39
  /*Coverage entropy=1.0397207708399179
  */
  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      
      Attribute attribute0 = new Attribute("/W;68a0+`");
      assertNotNull(attribute0);
      assertTrue(attribute0.isRegular());
      assertEquals("/W;68a0+`", attribute0.name());
      assertTrue(attribute0.hasZeropoint());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isAveragable());
      assertEquals("", attribute0.getDateFormat());
      assertFalse(attribute0.isRelationValued());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isString());
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(1, attribute0.ordering());
      assertFalse(attribute0.isDate());
      assertTrue(attribute0.isNumeric());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertEquals(0, attribute0.type());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(3, Attribute.DATE);
      assertEquals(4, Attribute.RELATIONAL);
      
      bestFirst0.m_searchDirection = 0;
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      
      String string0 = bestFirst0.toString();
      assertNotNull(string0);
      assertEquals("\tBest first.\n\tStart set: no attributes\n\tSearch direction: backward\n\tStale search after 5 node expansions\n\tTotal number of subsets evaluated: 0\n\tMerit of best subset found:    0    \n", string0);
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
  }

  /**
  //Test case number: 40
  /*Coverage entropy=1.6443863156232512
  */
  @Test(timeout = 4000)
  public void test40()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      
      Attribute attribute0 = new Attribute("-Q?");
      assertNotNull(attribute0);
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.isString());
      assertEquals("-Q?", attribute0.name());
      assertFalse(attribute0.isRelationValued());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals(1, attribute0.ordering());
      assertTrue(attribute0.hasZeropoint());
      assertTrue(attribute0.isAveragable());
      assertFalse(attribute0.isNominal());
      assertEquals("", attribute0.getDateFormat());
      assertTrue(attribute0.isRegular());
      assertEquals(0, attribute0.numValues());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertTrue(attribute0.isNumeric());
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(0, attribute0.type());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertFalse(arrayList0.contains(attribute0));
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      
      boolean boolean0 = arrayList0.add(attribute0);
      assertTrue(boolean0);
      assertTrue(arrayList0.contains(attribute0));
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.isString());
      assertEquals("-Q?", attribute0.name());
      assertFalse(attribute0.isRelationValued());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals(1, attribute0.ordering());
      assertTrue(attribute0.hasZeropoint());
      assertTrue(attribute0.isAveragable());
      assertFalse(attribute0.isNominal());
      assertEquals("", attribute0.getDateFormat());
      assertTrue(attribute0.isRegular());
      assertEquals(0, attribute0.numValues());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertTrue(attribute0.isNumeric());
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(0, attribute0.type());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      
      Instances instances0 = new Instances("real", arrayList0, 8);
      assertNotNull(instances0);
      assertTrue(arrayList0.contains(attribute0));
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals((-1), instances0.classIndex());
      assertEquals("real", instances0.relationName());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      
      AttributeSelectedClassifier attributeSelectedClassifier0 = new AttributeSelectedClassifier();
      assertNotNull(attributeSelectedClassifier0);
      assertEquals("Dimensionality of training and test data is reduced by attribute selection before being passed on to a classifier.", attributeSelectedClassifier0.globalInfo());
      assertEquals(0.0, attributeSelectedClassifier0.measureSelectionTime(), 0.01);
      assertEquals("The base classifier to be used.", attributeSelectedClassifier0.classifierTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", attributeSelectedClassifier0.debugTipText());
      assertFalse(attributeSelectedClassifier0.getDebug());
      assertEquals(0.0, attributeSelectedClassifier0.measureNumAttributesSelected(), 0.01);
      assertEquals("Set the search method. This search method is used during the attribute selection phase before the classifier is invoked.", attributeSelectedClassifier0.searchTipText());
      assertEquals("Set the attribute evaluator to use. This evaluator is used during the attribute selection phase before the classifier is invoked.", attributeSelectedClassifier0.evaluatorTipText());
      assertEquals(1, attributeSelectedClassifier0.graphType());
      assertEquals(0.0, attributeSelectedClassifier0.measureTime(), 0.01);
      
      Attribute attribute1 = new Attribute("date");
      assertNotNull(attribute1);
      assertTrue(attribute1.isAveragable());
      assertFalse(attribute1.isNominal());
      assertEquals("", attribute1.getDateFormat());
      assertTrue(attribute1.isNumeric());
      assertEquals("date", attribute1.name());
      assertEquals(0, attribute1.numValues());
      assertEquals(Double.NEGATIVE_INFINITY, attribute1.getLowerNumericBound(), 0.01);
      assertTrue(attribute1.isRegular());
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertFalse(attribute1.isDate());
      assertFalse(attribute1.isString());
      assertEquals(0, attribute1.type());
      assertEquals(Double.POSITIVE_INFINITY, attribute1.getUpperNumericBound(), 0.01);
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertEquals(1, attribute1.ordering());
      assertTrue(attribute1.hasZeropoint());
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertFalse(attribute1.isRelationValued());
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(3, Attribute.DATE);
      assertEquals(4, Attribute.RELATIONAL);
      assertFalse(attribute1.equals((Object)attribute0));
      
      boolean boolean1 = arrayList0.add(attribute1);
      assertNotSame(attribute1, attribute0);
      assertTrue(boolean1);
      assertTrue(arrayList0.contains(attribute1));
      assertEquals(2, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertTrue(attribute1.isAveragable());
      assertFalse(attribute1.isNominal());
      assertEquals("", attribute1.getDateFormat());
      assertTrue(attribute1.isNumeric());
      assertEquals("date", attribute1.name());
      assertEquals(0, attribute1.numValues());
      assertEquals(Double.NEGATIVE_INFINITY, attribute1.getLowerNumericBound(), 0.01);
      assertTrue(attribute1.isRegular());
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertFalse(attribute1.isDate());
      assertFalse(attribute1.isString());
      assertEquals(0, attribute1.type());
      assertEquals(Double.POSITIVE_INFINITY, attribute1.getUpperNumericBound(), 0.01);
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertEquals(1, attribute1.ordering());
      assertTrue(attribute1.hasZeropoint());
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertFalse(attribute1.isRelationValued());
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(3, Attribute.DATE);
      assertEquals(4, Attribute.RELATIONAL);
      assertFalse(attribute1.equals((Object)attribute0));
      assertTrue(boolean1 == boolean0);
      
      Attribute attribute2 = new Attribute("@end");
      assertNotNull(attribute2);
      assertTrue(attribute2.hasZeropoint());
      assertEquals(0, attribute2.numValues());
      assertTrue(attribute2.isAveragable());
      assertEquals(0, attribute2.type());
      assertEquals("", attribute2.getDateFormat());
      assertTrue(attribute2.isRegular());
      assertEquals("@end", attribute2.name());
      assertFalse(attribute2.upperNumericBoundIsOpen());
      assertEquals(1, attribute2.ordering());
      assertEquals(Double.NEGATIVE_INFINITY, attribute2.getLowerNumericBound(), 0.01);
      assertTrue(attribute2.isNumeric());
      assertEquals(1.0, attribute2.weight(), 0.01);
      assertEquals(Double.POSITIVE_INFINITY, attribute2.getUpperNumericBound(), 0.01);
      assertFalse(attribute2.lowerNumericBoundIsOpen());
      assertFalse(attribute2.isDate());
      assertFalse(attribute2.isNominal());
      assertFalse(attribute2.isString());
      assertFalse(attribute2.isRelationValued());
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(3, Attribute.DATE);
      assertFalse(attribute2.equals((Object)attribute1));
      assertFalse(attribute2.equals((Object)attribute0));
      
      boolean boolean2 = arrayList0.add(attribute2);
      assertNotSame(attribute2, attribute1);
      assertNotSame(attribute2, attribute0);
      assertTrue(boolean2);
      assertTrue(arrayList0.contains(attribute1));
      assertFalse(arrayList0.isEmpty());
      assertEquals(3, arrayList0.size());
      assertTrue(attribute2.hasZeropoint());
      assertEquals(0, attribute2.numValues());
      assertTrue(attribute2.isAveragable());
      assertEquals(0, attribute2.type());
      assertEquals("", attribute2.getDateFormat());
      assertTrue(attribute2.isRegular());
      assertEquals("@end", attribute2.name());
      assertFalse(attribute2.upperNumericBoundIsOpen());
      assertEquals(1, attribute2.ordering());
      assertEquals(Double.NEGATIVE_INFINITY, attribute2.getLowerNumericBound(), 0.01);
      assertTrue(attribute2.isNumeric());
      assertEquals(1.0, attribute2.weight(), 0.01);
      assertEquals(Double.POSITIVE_INFINITY, attribute2.getUpperNumericBound(), 0.01);
      assertFalse(attribute2.lowerNumericBoundIsOpen());
      assertFalse(attribute2.isDate());
      assertFalse(attribute2.isNominal());
      assertFalse(attribute2.isString());
      assertFalse(attribute2.isRelationValued());
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(3, Attribute.DATE);
      assertFalse(attribute2.equals((Object)attribute1));
      assertFalse(attribute2.equals((Object)attribute0));
      assertTrue(boolean2 == boolean1);
      assertTrue(boolean2 == boolean0);
      
      Instances instances1 = new Instances("XJ8?t,5EY ,hpQJ:", arrayList0, 80);
      assertNotNull(instances1);
      assertTrue(arrayList0.contains(attribute1));
      assertFalse(arrayList0.isEmpty());
      assertEquals(3, arrayList0.size());
      assertEquals((-1), instances1.classIndex());
      assertEquals(0.0, instances1.sumOfWeights(), 0.01);
      assertEquals(0, instances1.size());
      assertEquals(3, instances1.numAttributes());
      assertEquals(0, instances1.numInstances());
      assertEquals("XJ8?t,5EY ,hpQJ:", instances1.relationName());
      assertFalse(instances1.checkForStringAttributes());
      assertTrue(instances1.equals((Object)instances0));
      
      CfsSubsetEval cfsSubsetEval0 = new CfsSubsetEval();
      assertNotNull(cfsSubsetEval0);
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      
      int[] intArray0 = bestFirst0.search(cfsSubsetEval0, instances0);
      assertNotNull(intArray0);
      assertNotSame(instances0, instances1);
      assertArrayEquals(new int[] {}, intArray0);
      assertTrue(arrayList0.contains(attribute1));
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertFalse(arrayList0.isEmpty());
      assertEquals(3, arrayList0.size());
      assertEquals((-1), instances0.classIndex());
      assertEquals("real", instances0.relationName());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(3, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertEquals(0, intArray0.length);
      assertTrue(instances0.equals((Object)instances1));
  }

  /**
  //Test case number: 41
  /*Coverage entropy=1.2275294114572126
  */
  @Test(timeout = 4000)
  public void test41()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      
      int[] intArray0 = new int[1];
      bestFirst0.m_classIndex = 0;
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      
      bestFirst0.m_hasClass = true;
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      
      bestFirst0.m_starting = intArray0;
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      
      String string0 = bestFirst0.toString();
      assertNotNull(string0);
      assertEquals("\tBest first.\n\tStart set: \n\tSearch direction: forward\n\tStale search after 5 node expansions\n\tTotal number of subsets evaluated: 0\n\tMerit of best subset found:    0    \n", string0);
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      
      AttributeSelectedClassifier attributeSelectedClassifier0 = new AttributeSelectedClassifier();
      assertNotNull(attributeSelectedClassifier0);
      assertEquals(0.0, attributeSelectedClassifier0.measureTime(), 0.01);
      assertEquals(1, attributeSelectedClassifier0.graphType());
      assertEquals(0.0, attributeSelectedClassifier0.measureSelectionTime(), 0.01);
      assertEquals("Set the attribute evaluator to use. This evaluator is used during the attribute selection phase before the classifier is invoked.", attributeSelectedClassifier0.evaluatorTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", attributeSelectedClassifier0.debugTipText());
      assertFalse(attributeSelectedClassifier0.getDebug());
      assertEquals(0.0, attributeSelectedClassifier0.measureNumAttributesSelected(), 0.01);
      assertEquals("The base classifier to be used.", attributeSelectedClassifier0.classifierTipText());
      assertEquals("Set the search method. This search method is used during the attribute selection phase before the classifier is invoked.", attributeSelectedClassifier0.searchTipText());
      assertEquals("Dimensionality of training and test data is reduced by attribute selection before being passed on to a classifier.", attributeSelectedClassifier0.globalInfo());
      
      CfsSubsetEval cfsSubsetEval0 = (CfsSubsetEval)attributeSelectedClassifier0.getEvaluator();
      assertNotNull(cfsSubsetEval0);
      assertEquals(0.0, attributeSelectedClassifier0.measureTime(), 0.01);
      assertEquals(1, attributeSelectedClassifier0.graphType());
      assertEquals(0.0, attributeSelectedClassifier0.measureSelectionTime(), 0.01);
      assertEquals("Set the attribute evaluator to use. This evaluator is used during the attribute selection phase before the classifier is invoked.", attributeSelectedClassifier0.evaluatorTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", attributeSelectedClassifier0.debugTipText());
      assertFalse(attributeSelectedClassifier0.getDebug());
      assertEquals(0.0, attributeSelectedClassifier0.measureNumAttributesSelected(), 0.01);
      assertEquals("The base classifier to be used.", attributeSelectedClassifier0.classifierTipText());
      assertEquals("Set the search method. This search method is used during the attribute selection phase before the classifier is invoked.", attributeSelectedClassifier0.searchTipText());
      assertEquals("Dimensionality of training and test data is reduced by attribute selection before being passed on to a classifier.", attributeSelectedClassifier0.globalInfo());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      
      try { 
        bestFirst0.search(cfsSubsetEval0, (Instances) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.attributeSelection.BestFirst", e);
      }
  }

  /**
  //Test case number: 42
  /*Coverage entropy=1.3893804876429847
  */
  @Test(timeout = 4000)
  public void test42()  throws Throwable  {
      BestFirst bestFirst0 = new BestFirst();
      assertNotNull(bestFirst0);
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      
      CfsSubsetEval cfsSubsetEval0 = new CfsSubsetEval();
      assertNotNull(cfsSubsetEval0);
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      
      String string0 = cfsSubsetEval0.toString();
      assertNotNull(string0);
      assertEquals("CFS subset evaluator has not been built yet\n", string0);
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      
      Attribute attribute0 = new Attribute("/W;+:aqS0<");
      assertNotNull(attribute0);
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals("", attribute0.getDateFormat());
      assertTrue(attribute0.isNumeric());
      assertTrue(attribute0.isAveragable());
      assertEquals(1, attribute0.ordering());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertTrue(attribute0.isRegular());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertEquals(0, attribute0.numValues());
      assertEquals(0, attribute0.type());
      assertTrue(attribute0.hasZeropoint());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isString());
      assertEquals("/W;+:aqS0<", attribute0.name());
      assertFalse(attribute0.isRelationValued());
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      
      boolean boolean0 = arrayList0.add(attribute0);
      assertTrue(boolean0);
      assertTrue(arrayList0.contains(attribute0));
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals("", attribute0.getDateFormat());
      assertTrue(attribute0.isNumeric());
      assertTrue(attribute0.isAveragable());
      assertEquals(1, attribute0.ordering());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertTrue(attribute0.isRegular());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertEquals(0, attribute0.numValues());
      assertEquals(0, attribute0.type());
      assertTrue(attribute0.hasZeropoint());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isString());
      assertEquals("/W;+:aqS0<", attribute0.name());
      assertFalse(attribute0.isRelationValued());
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      
      bestFirst0.m_searchDirection = 0;
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      
      Instances instances0 = new Instances("string", arrayList0, 3);
      assertNotNull(instances0);
      assertTrue(arrayList0.contains(attribute0));
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals("string", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertEquals(1, instances0.numAttributes());
      assertEquals((-1), instances0.classIndex());
      
      instances0.setClass(attribute0);
      assertTrue(arrayList0.contains(attribute0));
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals("", attribute0.getDateFormat());
      assertTrue(attribute0.isNumeric());
      assertTrue(attribute0.isAveragable());
      assertEquals(1, attribute0.ordering());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertTrue(attribute0.isRegular());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertEquals(0, attribute0.numValues());
      assertEquals(0, attribute0.type());
      assertTrue(attribute0.hasZeropoint());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isString());
      assertEquals("/W;+:aqS0<", attribute0.name());
      assertFalse(attribute0.isRelationValued());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals("string", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0, instances0.classIndex());
      assertEquals(1, instances0.numClasses());
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      
      int[] intArray0 = bestFirst0.search(cfsSubsetEval0, instances0);
      assertNotNull(intArray0);
      assertArrayEquals(new int[] {}, intArray0);
      assertTrue(arrayList0.contains(attribute0));
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals("string", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0, instances0.classIndex());
      assertEquals(1, instances0.numClasses());
      assertEquals(0, intArray0.length);
  }
}
