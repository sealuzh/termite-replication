/*
 * This file was automatically generated by EvoSuite
 * Tue Aug 07 14:06:22 GMT 2018
 */

package weka.attributeSelection;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.BufferedReader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Locale;
import java.util.function.UnaryOperator;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.System;
import org.evosuite.runtime.mock.java.util.MockRandom;
import org.junit.runner.RunWith;
import weka.attributeSelection.ASEvaluation;
import weka.attributeSelection.BestFirst;
import weka.attributeSelection.CfsSubsetEval;
import weka.attributeSelection.GainRatioAttributeEval;
import weka.attributeSelection.GreedyStepwise;
import weka.attributeSelection.PrincipalComponents;
import weka.classifiers.CostMatrix;
import weka.classifiers.meta.AttributeSelectedClassifier;
import weka.classifiers.misc.InputMappedClassifier;
import weka.core.Attribute;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Range;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class GreedyStepwise_ESTest extends GreedyStepwise_ESTest_scaffolding {

  /**
  //Test case number: 0
  /*Coverage entropy=1.0986122886681096
  */
  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      String string0 = greedyStepwise0.globalInfo();
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", string0);
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
  }

  /**
  //Test case number: 1
  /*Coverage entropy=1.3862943611198906
  */
  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      assertFalse(greedyStepwise0.getSearchBackwards());
      
      greedyStepwise0.setSearchBackwards(true);
      assertTrue(greedyStepwise0.getSearchBackwards());
  }

  /**
  //Test case number: 2
  /*Coverage entropy=1.7917594692280547
  */
  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      greedyStepwise0.setOptions((String[]) null);
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
  }

  /**
  //Test case number: 3
  /*Coverage entropy=2.3025850929940455
  */
  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      assertFalse(greedyStepwise0.getSearchBackwards());
      
      greedyStepwise0.m_backward = true;
      greedyStepwise0.getOptions();
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      greedyStepwise0.toString();
      assertTrue(greedyStepwise0.getSearchBackwards());
  }

  /**
  //Test case number: 4
  /*Coverage entropy=2.3114234446919735
  */
  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      greedyStepwise0.setStartSet("WeightSum =");
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      ArrayList<Attribute> arrayList1 = new ArrayList<Attribute>();
      GainRatioAttributeEval gainRatioAttributeEval0 = new GainRatioAttributeEval();
      String[] stringArray0 = greedyStepwise0.getOptions();
      assertEquals(9, stringArray0.length);
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
  }

  /**
  //Test case number: 5
  /*Coverage entropy=1.0986122886681096
  */
  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      greedyStepwise0.listOptions();
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
  }

  /**
  //Test case number: 6
  /*Coverage entropy=1.0986122886681096
  */
  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      String string0 = greedyStepwise0.getRevision();
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertEquals("8034", string0);
      assertEquals((-1), greedyStepwise0.getNumToSelect());
  }

  /**
  //Test case number: 7
  /*Coverage entropy=1.0986122886681096
  */
  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      String string0 = greedyStepwise0.conservativeForwardSelectionTipText();
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", string0);
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
  }

  /**
  //Test case number: 8
  /*Coverage entropy=1.6094379124341005
  */
  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      greedyStepwise0.startSetToString();
      int int0 = greedyStepwise0.getCalculatedNumToSelect();
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals(0, int0);
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getSearchBackwards());
  }

  /**
  //Test case number: 9
  /*Coverage entropy=1.0986122886681096
  */
  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      String string0 = greedyStepwise0.numToSelectTipText();
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", string0);
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertFalse(greedyStepwise0.getSearchBackwards());
  }

  /**
  //Test case number: 10
  /*Coverage entropy=1.0986122886681096
  */
  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      String string0 = greedyStepwise0.generateRankingTipText();
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertEquals("Set to true if a ranked list is required.", string0);
  }

  /**
  //Test case number: 11
  /*Coverage entropy=1.0986122886681096
  */
  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      String string0 = greedyStepwise0.startSetTipText();
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", string0);
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
  }

  /**
  //Test case number: 12
  /*Coverage entropy=1.0986122886681096
  */
  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      String string0 = greedyStepwise0.searchBackwardsTipText();
      assertEquals("Search backwards rather than forwards.", string0);
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
  }

  /**
  //Test case number: 13
  /*Coverage entropy=2.70805020110221
  */
  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      String[] stringArray0 = greedyStepwise0.getOptions();
      greedyStepwise0.setOptions(stringArray0);
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals(9, stringArray0.length);
  }

  /**
  //Test case number: 14
  /*Coverage entropy=0.8675632284814612
  */
  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      greedyStepwise0.m_hasClass = true;
      int[] intArray0 = new int[14];
      greedyStepwise0.m_starting = intArray0;
      String string0 = greedyStepwise0.startSetToString();
      assertEquals("1,1,1,1,1,1,1,1,1,1,1,1,1", string0);
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
  }

  /**
  //Test case number: 15
  /*Coverage entropy=1.7917594692280547
  */
  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      greedyStepwise0.setNumToSelect(1014);
      greedyStepwise0.startSetToString();
      int int0 = greedyStepwise0.getCalculatedNumToSelect();
      assertEquals(1014, greedyStepwise0.getNumToSelect());
      assertEquals(1014, int0);
  }

  /**
  //Test case number: 16
  /*Coverage entropy=1.3030924037617193
  */
  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertNotNull(greedyStepwise0);
      
      greedyStepwise0.setThreshold(608.37676293);
      assertEquals(608.37676293, greedyStepwise0.getThreshold(), 0.01);
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      
      String string0 = greedyStepwise0.getStartSet();
      assertEquals(608.37676293, greedyStepwise0.getThreshold(), 0.01);
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertNotNull(string0);
      assertEquals("", string0);
      
      String string1 = greedyStepwise0.toString();
      assertEquals(608.37676293, greedyStepwise0.getThreshold(), 0.01);
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertNotNull(string1);
      assertEquals("\tGreedy Stepwise (forwards).\n\tStart set: no attributes\n\tMerit of best subset found:    0    \n", string1);
      assertFalse(string1.equals((Object)string0));
  }

  /**
  //Test case number: 17
  /*Coverage entropy=2.2718685126965625
  */
  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertNotNull(greedyStepwise0);
      
      greedyStepwise0.setConservativeForwardSelection(true);
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertTrue(greedyStepwise0.getConservativeForwardSelection());
      
      String[] stringArray0 = greedyStepwise0.getOptions();
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertTrue(greedyStepwise0.getConservativeForwardSelection());
      assertEquals(9, stringArray0.length);
      assertNotNull(stringArray0);
      
      String[] stringArray1 = greedyStepwise0.getOptions();
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertTrue(greedyStepwise0.getConservativeForwardSelection());
      assertEquals(9, stringArray1.length);
      assertNotNull(stringArray1);
      assertNotSame(stringArray1, stringArray0);
      assertFalse(stringArray1.equals((Object)stringArray0));
  }

  /**
  //Test case number: 18
  /*Coverage entropy=1.0335620542068176
  */
  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertNotNull(greedyStepwise0);
      
      int[] intArray0 = new int[3];
      greedyStepwise0.m_starting = intArray0;
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      
      String string0 = greedyStepwise0.toString();
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertNotNull(string0);
      assertEquals("\tGreedy Stepwise (forwards).\n\tStart set: 1,1,1\n\tMerit of best subset found:    0    \n", string0);
  }

  /**
  //Test case number: 19
  /*Coverage entropy=1.5810937501718236
  */
  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertNotNull(arrayList0);
      
      Instances instances0 = new Instances(")-wQr7\"0", arrayList0, 8);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(")-wQr7\"0", instances0.relationName());
      assertEquals(0, instances0.numAttributes());
      assertNotNull(instances0);
      
      Attribute attribute0 = new Attribute(".arff");
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(1, attribute0.ordering());
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.isDate());
      assertEquals(0, attribute0.type());
      assertEquals("", attribute0.getDateFormat());
      assertTrue(attribute0.isRegular());
      assertTrue(attribute0.hasZeropoint());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isAveragable());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertTrue(attribute0.isNumeric());
      assertFalse(attribute0.isString());
      assertEquals(".arff", attribute0.name());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isRelationValued());
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(3, Attribute.DATE);
      assertNotNull(attribute0);
      
      boolean boolean0 = arrayList0.add(attribute0);
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(1, attribute0.ordering());
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.isDate());
      assertEquals(0, attribute0.type());
      assertEquals("", attribute0.getDateFormat());
      assertTrue(attribute0.isRegular());
      assertTrue(attribute0.hasZeropoint());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isAveragable());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertTrue(attribute0.isNumeric());
      assertFalse(attribute0.isString());
      assertEquals(".arff", attribute0.name());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isRelationValued());
      assertTrue(arrayList0.contains(attribute0));
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(3, Attribute.DATE);
      assertTrue(boolean0);
      
      CfsSubsetEval cfsSubsetEval0 = new CfsSubsetEval();
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertNotNull(cfsSubsetEval0);
      
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertNotNull(greedyStepwise0);
      
      int[] intArray0 = greedyStepwise0.search(cfsSubsetEval0, instances0);
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(1, instances0.numAttributes());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(")-wQr7\"0", instances0.relationName());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals(0, intArray0.length);
      assertTrue(arrayList0.contains(attribute0));
      assertNotNull(intArray0);
      assertArrayEquals(new int[] {}, intArray0);
      
      double[][] doubleArray0 = greedyStepwise0.rankedAttributes();
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals(1, doubleArray0.length);
      assertNotNull(doubleArray0);
  }

  /**
  //Test case number: 20
  /*Coverage entropy=0.8675632284814612
  */
  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertNotNull(greedyStepwise0);
      
      greedyStepwise0.m_doneRanking = true;
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      
      greedyStepwise0.m_backward = true;
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertTrue(greedyStepwise0.getSearchBackwards());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertFalse(greedyStepwise0.getSearchBackwards());
      
      String string0 = greedyStepwise0.toString();
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertTrue(greedyStepwise0.getSearchBackwards());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertNotNull(string0);
      assertEquals("\tGreedy Stepwise (backwards).\n\tStart set: all attributes\n\n\tRanking is the order that attributes were removed, starting \n\twith all attributes. The merit scores in the left\n\tcolumn are the goodness of the remaining attributes in the\n\tsubset after removing the corresponding in the right column\n\tattribute from the subset.\n", string0);
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertEquals("\tGreedy Stepwise (forwards).\n\tStart set: no attributes\n\n\tRanking is the order that attributes were added, starting \n\twith no attributes. The merit scores in the left column\n\tare the goodness of the subset after the adding the\n\tcorresponding attribute in the right column to the subset.\n", string0);
  }

  /**
  //Test case number: 21
  /*Coverage entropy=0.9404479886553263
  */
  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertNotNull(greedyStepwise0);
      
      greedyStepwise0.m_doneRanking = true;
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      
      greedyStepwise0.setThreshold(608.37676293);
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals(608.37676293, greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      
      String string0 = greedyStepwise0.toString();
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals(608.37676293, greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertNotNull(string0);
      assertEquals("\tGreedy Stepwise (forwards).\n\tStart set: no attributes\n\n\tRanking is the order that attributes were added, starting \n\twith no attributes. The merit scores in the left column\n\tare the goodness of the subset after the adding the\n\tcorresponding attribute in the right column to the subset.\n\tThreshold for discarding attributes: 608.3768\n", string0);
  }

  /**
  //Test case number: 22
  /*Coverage entropy=2.9444389791664403
  */
  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertNotNull(greedyStepwise0);
      
      String string0 = greedyStepwise0.thresholdTipText();
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertNotNull(string0);
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", string0);
      
      greedyStepwise0.setStartSet("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking");
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      
      String[] stringArray0 = greedyStepwise0.getOptions();
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals(9, stringArray0.length);
      assertNotNull(stringArray0);
      
      greedyStepwise0.setOptions(stringArray0);
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals(9, stringArray0.length);
      
      System.setCurrentTimeMillis(120L);
      PrincipalComponents principalComponents0 = new PrincipalComponents();
      assertEquals("The maximum number of attributes to include in transformed attribute names.", principalComponents0.maximumAttributeNamesTipText());
      assertEquals("Performs a principal components analysis and transformation of the data. Use in conjunction with a Ranker search. Dimensionality reduction is accomplished by choosing enough eigenvectors to account for some percentage of the variance in the original data---default 0.95 (95%). Attribute noise can be filtered by transforming to the PC space, eliminating some of the worst eigenvectors, and then transforming back to the original space.", principalComponents0.globalInfo());
      assertEquals(5, principalComponents0.getMaximumAttributeNames());
      assertEquals("Center (rather than standardize) the data. PCA will be computed from the covariance (rather than correlation) matrix", principalComponents0.centerDataTipText());
      assertEquals("Retain enough PC attributes to account for this proportion of variance.", principalComponents0.varianceCoveredTipText());
      assertEquals("Transform through the PC space and back to the original space. If only the best n PCs are retained (by setting varianceCovered < 1) then this option will give a dataset in the original space but with less attribute noise.", principalComponents0.transformBackToOriginalTipText());
      assertEquals(0.95, principalComponents0.getVarianceCovered(), 0.01);
      assertFalse(principalComponents0.getTransformBackToOriginal());
      assertFalse(principalComponents0.getCenterData());
      assertNotNull(principalComponents0);
      
      try { 
        greedyStepwise0.search(principalComponents0, (Instances) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.attributeSelection.GreedyStepwise", e);
      }
  }

  /**
  //Test case number: 23
  /*Coverage entropy=1.0397207708399179
  */
  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertNotNull(greedyStepwise0);
      
      double[][] doubleArray0 = new double[0][4];
      greedyStepwise0.m_rankedAtts = doubleArray0;
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      
      try { 
        greedyStepwise0.rankedAttributes();
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // Search must be performed before attributes can be ranked.
         //
         verifyException("weka.attributeSelection.GreedyStepwise", e);
      }
  }

  /**
  //Test case number: 24
  /*Coverage entropy=0.9502705392332347
  */
  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertNotNull(arrayList0);
      
      Instances instances0 = new Instances("|q", arrayList0, 1753);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numAttributes());
      assertEquals("|q", instances0.relationName());
      assertNotNull(instances0);
      
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertNotNull(greedyStepwise0);
      
      ASEvaluation aSEvaluation0 = greedyStepwise0.m_ASEval;
      assertNull(aSEvaluation0);
      
      try { 
        greedyStepwise0.search((ASEvaluation) null, instances0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.attributeSelection.GreedyStepwise", e);
      }
  }

  /**
  //Test case number: 25
  /*Coverage entropy=2.338371704803573
  */
  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertNotNull(greedyStepwise0);
      
      String string0 = greedyStepwise0.toString();
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertNotNull(string0);
      assertEquals("\tGreedy Stepwise (forwards).\n\tStart set: no attributes\n\tMerit of best subset found:    0    \n", string0);
      
      greedyStepwise0.setGenerateRanking(true);
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertTrue(greedyStepwise0.getGenerateRanking());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      
      String[] stringArray0 = greedyStepwise0.getOptions();
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertTrue(greedyStepwise0.getGenerateRanking());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertEquals(9, stringArray0.length);
      assertNotNull(stringArray0);
      
      greedyStepwise0.setConservativeForwardSelection(true);
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertTrue(greedyStepwise0.getGenerateRanking());
      assertTrue(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
  }

  /**
  //Test case number: 26
  /*Coverage entropy=1.3961713253411865
  */
  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertNotNull(arrayList0);
      
      Instances instances0 = new Instances("~c;zr=+7JO|9YbY", arrayList0, 55);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertEquals("~c;zr=+7JO|9YbY", instances0.relationName());
      assertNotNull(instances0);
      
      CfsSubsetEval cfsSubsetEval0 = new CfsSubsetEval();
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertNotNull(cfsSubsetEval0);
      
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertNotNull(greedyStepwise0);
      
      greedyStepwise0.setThreshold(1874.0);
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals(1874.0, greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      
      int[] intArray0 = greedyStepwise0.search(cfsSubsetEval0, instances0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertEquals("~c;zr=+7JO|9YbY", instances0.relationName());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals(1874.0, greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals(0, intArray0.length);
      assertNotNull(intArray0);
      assertArrayEquals(new int[] {}, intArray0);
      
      double[][] doubleArray0 = greedyStepwise0.rankedAttributes();
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals(1874.0, greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals(0, doubleArray0.length);
      assertNotNull(doubleArray0);
  }

  /**
  //Test case number: 27
  /*Coverage entropy=1.5377034978212434
  */
  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertNotNull(arrayList0);
      
      Instances instances0 = new Instances(")-wQr7\"0", arrayList0, 8);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, instances0.numAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals((-1), instances0.classIndex());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(")-wQr7\"0", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertNotNull(instances0);
      
      Attribute attribute0 = new Attribute(".arff");
      assertTrue(attribute0.isRegular());
      assertEquals(".arff", attribute0.name());
      assertFalse(attribute0.isNominal());
      assertTrue(attribute0.isNumeric());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertEquals(0, attribute0.numValues());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(0, attribute0.type());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.isRelationValued());
      assertEquals("", attribute0.getDateFormat());
      assertTrue(attribute0.isAveragable());
      assertTrue(attribute0.hasZeropoint());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals(1, attribute0.ordering());
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.STRING);
      assertNotNull(attribute0);
      
      boolean boolean0 = arrayList0.add(attribute0);
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertTrue(attribute0.isRegular());
      assertEquals(".arff", attribute0.name());
      assertFalse(attribute0.isNominal());
      assertTrue(attribute0.isNumeric());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertEquals(0, attribute0.numValues());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(0, attribute0.type());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.isRelationValued());
      assertEquals("", attribute0.getDateFormat());
      assertTrue(attribute0.isAveragable());
      assertTrue(attribute0.hasZeropoint());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals(1, attribute0.ordering());
      assertTrue(arrayList0.contains(attribute0));
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.STRING);
      assertTrue(boolean0);
      
      CfsSubsetEval cfsSubsetEval0 = new CfsSubsetEval();
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertNotNull(cfsSubsetEval0);
      
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertNotNull(greedyStepwise0);
      
      greedyStepwise0.m_threshold = (double) 8;
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals(8.0, greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      
      int[] intArray0 = greedyStepwise0.search(cfsSubsetEval0, instances0);
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals((-1), instances0.classIndex());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(")-wQr7\"0", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals(8.0, greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals(0, intArray0.length);
      assertTrue(arrayList0.contains(attribute0));
      assertNotNull(intArray0);
      assertArrayEquals(new int[] {}, intArray0);
      
      double[][] doubleArray0 = greedyStepwise0.rankedAttributes();
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals(8.0, greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals(1, doubleArray0.length);
      assertNotNull(doubleArray0);
  }

  /**
  //Test case number: 28
  /*Coverage entropy=1.3862943611198906
  */
  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertNotNull(arrayList0);
      
      Instances instances0 = new Instances("kHV-w&G:+2m;p", arrayList0, 17);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertEquals((-1), instances0.classIndex());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numAttributes());
      assertEquals("kHV-w&G:+2m;p", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertNotNull(instances0);
      
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertNotNull(greedyStepwise0);
      
      AttributeSelectedClassifier attributeSelectedClassifier0 = new AttributeSelectedClassifier();
      assertEquals("Set the search method. This search method is used during the attribute selection phase before the classifier is invoked.", attributeSelectedClassifier0.searchTipText());
      assertFalse(attributeSelectedClassifier0.getDebug());
      assertEquals(0.0, attributeSelectedClassifier0.measureTime(), 0.01);
      assertEquals("Dimensionality of training and test data is reduced by attribute selection before being passed on to a classifier.", attributeSelectedClassifier0.globalInfo());
      assertEquals("If set to true, classifier may output additional info to the console.", attributeSelectedClassifier0.debugTipText());
      assertEquals("The base classifier to be used.", attributeSelectedClassifier0.classifierTipText());
      assertEquals(1, attributeSelectedClassifier0.graphType());
      assertEquals(0.0, attributeSelectedClassifier0.measureSelectionTime(), 0.01);
      assertEquals("Set the attribute evaluator to use. This evaluator is used during the attribute selection phase before the classifier is invoked.", attributeSelectedClassifier0.evaluatorTipText());
      assertEquals(0.0, attributeSelectedClassifier0.measureNumAttributesSelected(), 0.01);
      assertNotNull(attributeSelectedClassifier0);
      
      greedyStepwise0.setStartSet(".arff");
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      
      CfsSubsetEval cfsSubsetEval0 = (CfsSubsetEval)attributeSelectedClassifier0.getEvaluator();
      assertEquals("Set the search method. This search method is used during the attribute selection phase before the classifier is invoked.", attributeSelectedClassifier0.searchTipText());
      assertFalse(attributeSelectedClassifier0.getDebug());
      assertEquals(0.0, attributeSelectedClassifier0.measureTime(), 0.01);
      assertEquals("Dimensionality of training and test data is reduced by attribute selection before being passed on to a classifier.", attributeSelectedClassifier0.globalInfo());
      assertEquals("If set to true, classifier may output additional info to the console.", attributeSelectedClassifier0.debugTipText());
      assertEquals("The base classifier to be used.", attributeSelectedClassifier0.classifierTipText());
      assertEquals(1, attributeSelectedClassifier0.graphType());
      assertEquals(0.0, attributeSelectedClassifier0.measureSelectionTime(), 0.01);
      assertEquals("Set the attribute evaluator to use. This evaluator is used during the attribute selection phase before the classifier is invoked.", attributeSelectedClassifier0.evaluatorTipText());
      assertEquals(0.0, attributeSelectedClassifier0.measureNumAttributesSelected(), 0.01);
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertNotNull(cfsSubsetEval0);
      
      try { 
        greedyStepwise0.search(cfsSubsetEval0, instances0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // No upper limit has been specified for range
         //
         verifyException("weka.core.Range", e);
      }
  }

  /**
  //Test case number: 29
  /*Coverage entropy=1.7800229868966866
  */
  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertNotNull(arrayList0);
      
      ArrayList<Attribute> arrayList1 = new ArrayList<Attribute>();
      assertEquals(0, arrayList1.size());
      assertTrue(arrayList1.isEmpty());
      assertNotNull(arrayList1);
      assertTrue(arrayList1.equals((Object)arrayList0));
      
      Instances instances0 = new Instances("z]", arrayList1, 1753);
      assertEquals(0, arrayList1.size());
      assertTrue(arrayList1.isEmpty());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals("z]", instances0.relationName());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.numAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertNotNull(instances0);
      assertTrue(arrayList1.equals((Object)arrayList0));
      
      String[] stringArray0 = Locale.getISOCountries();
      assertEquals(250, stringArray0.length);
      assertNotNull(stringArray0);
      
      ArrayList<String> arrayList2 = new ArrayList<String>(1753);
      assertEquals(0, arrayList2.size());
      assertTrue(arrayList2.isEmpty());
      assertFalse(arrayList2.contains("z]"));
      assertNotNull(arrayList2);
      
      Attribute attribute0 = new Attribute(".bsi", arrayList2);
      assertEquals(0, arrayList2.size());
      assertTrue(arrayList2.isEmpty());
      assertEquals(".bsi", attribute0.name());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals("", attribute0.getDateFormat());
      assertTrue(attribute0.isNominal());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.isRegular());
      assertFalse(attribute0.isAveragable());
      assertEquals(1, attribute0.type());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.hasZeropoint());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isDate());
      assertEquals(0, attribute0.numValues());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0, attribute0.ordering());
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isNumeric());
      assertFalse(arrayList2.contains(".bsi"));
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(1, Attribute.NOMINAL);
      assertNotNull(attribute0);
      
      boolean boolean0 = arrayList1.add(attribute0);
      assertFalse(arrayList1.isEmpty());
      assertEquals(1, arrayList1.size());
      assertEquals(0, arrayList2.size());
      assertTrue(arrayList2.isEmpty());
      assertEquals(".bsi", attribute0.name());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals("", attribute0.getDateFormat());
      assertTrue(attribute0.isNominal());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.isRegular());
      assertFalse(attribute0.isAveragable());
      assertEquals(1, attribute0.type());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.hasZeropoint());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isDate());
      assertEquals(0, attribute0.numValues());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0, attribute0.ordering());
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isNumeric());
      assertTrue(arrayList1.contains(attribute0));
      assertFalse(arrayList2.contains(".bsi"));
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(1, Attribute.NOMINAL);
      assertNotSame(arrayList1, arrayList0);
      assertTrue(boolean0);
      assertFalse(arrayList1.equals((Object)arrayList0));
      
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertNotNull(greedyStepwise0);
      
      greedyStepwise0.setThreshold((-2838.4));
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-2838.4), greedyStepwise0.getThreshold(), 0.01);
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      
      AttributeSelectedClassifier attributeSelectedClassifier0 = new AttributeSelectedClassifier();
      assertEquals("Set the search method. This search method is used during the attribute selection phase before the classifier is invoked.", attributeSelectedClassifier0.searchTipText());
      assertFalse(attributeSelectedClassifier0.getDebug());
      assertEquals("The base classifier to be used.", attributeSelectedClassifier0.classifierTipText());
      assertEquals(0.0, attributeSelectedClassifier0.measureNumAttributesSelected(), 0.01);
      assertEquals(1, attributeSelectedClassifier0.graphType());
      assertEquals("Dimensionality of training and test data is reduced by attribute selection before being passed on to a classifier.", attributeSelectedClassifier0.globalInfo());
      assertEquals(0.0, attributeSelectedClassifier0.measureSelectionTime(), 0.01);
      assertEquals("Set the attribute evaluator to use. This evaluator is used during the attribute selection phase before the classifier is invoked.", attributeSelectedClassifier0.evaluatorTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", attributeSelectedClassifier0.debugTipText());
      assertEquals(0.0, attributeSelectedClassifier0.measureTime(), 0.01);
      assertNotNull(attributeSelectedClassifier0);
      
      CfsSubsetEval cfsSubsetEval0 = new CfsSubsetEval();
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertNotNull(cfsSubsetEval0);
      
      int[] intArray0 = greedyStepwise0.search(cfsSubsetEval0, instances0);
      assertFalse(arrayList1.isEmpty());
      assertEquals(1, arrayList1.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals("z]", instances0.relationName());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-2838.4), greedyStepwise0.getThreshold(), 0.01);
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals(0, intArray0.length);
      assertTrue(arrayList1.contains(attribute0));
      assertNotNull(intArray0);
      assertNotSame(arrayList1, arrayList0);
      assertFalse(arrayList1.equals((Object)arrayList0));
      assertArrayEquals(new int[] {}, intArray0);
      
      double[][] doubleArray0 = greedyStepwise0.rankedAttributes();
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-2838.4), greedyStepwise0.getThreshold(), 0.01);
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals(1, doubleArray0.length);
      assertNotNull(doubleArray0);
      
      String string0 = greedyStepwise0.startSetToString();
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-2838.4), greedyStepwise0.getThreshold(), 0.01);
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertNotNull(string0);
      assertEquals("", string0);
  }

  /**
  //Test case number: 30
  /*Coverage entropy=1.5810937501718236
  */
  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertNotNull(arrayList0);
      
      Instances instances0 = new Instances("~c;zr=+7JO|9YbY", arrayList0, 55);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, instances0.size());
      assertEquals("~c;zr=+7JO|9YbY", instances0.relationName());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals((-1), instances0.classIndex());
      assertFalse(instances0.checkForStringAttributes());
      assertNotNull(instances0);
      
      CfsSubsetEval cfsSubsetEval0 = new CfsSubsetEval();
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertNotNull(cfsSubsetEval0);
      
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertNotNull(greedyStepwise0);
      
      greedyStepwise0.m_numToSelect = 55;
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals(55, greedyStepwise0.getNumToSelect());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      
      int[] intArray0 = greedyStepwise0.search(cfsSubsetEval0, instances0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, instances0.size());
      assertEquals("~c;zr=+7JO|9YbY", instances0.relationName());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals((-1), instances0.classIndex());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals(55, greedyStepwise0.getNumToSelect());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals(0, intArray0.length);
      assertNotNull(intArray0);
      assertArrayEquals(new int[] {}, intArray0);
      
      try { 
        greedyStepwise0.rankedAttributes();
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // More attributes requested than exist in the data
         //
         verifyException("weka.attributeSelection.GreedyStepwise", e);
      }
  }

  /**
  //Test case number: 31
  /*Coverage entropy=1.0016550715972834
  */
  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertNotNull(greedyStepwise0);
      
      greedyStepwise0.m_backward = true;
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertTrue(greedyStepwise0.getSearchBackwards());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertNotNull(arrayList0);
      
      Instances instances0 = new Instances((String) null, arrayList0, 58);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals(0, instances0.numAttributes());
      assertEquals((-1), instances0.classIndex());
      assertNull(instances0.relationName());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertNotNull(instances0);
      
      Attribute attribute0 = new Attribute((String) null, 58);
      assertTrue(attribute0.isNumeric());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertTrue(attribute0.isAveragable());
      assertNull(attribute0.name());
      assertEquals("", attribute0.getDateFormat());
      assertTrue(attribute0.hasZeropoint());
      assertEquals(1, attribute0.ordering());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.isString());
      assertEquals(0, attribute0.type());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isDate());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isRegular());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(4, Attribute.RELATIONAL);
      assertNotNull(attribute0);
      
      boolean boolean0 = arrayList0.add(attribute0);
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertTrue(attribute0.isNumeric());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertTrue(attribute0.isAveragable());
      assertNull(attribute0.name());
      assertEquals("", attribute0.getDateFormat());
      assertTrue(attribute0.hasZeropoint());
      assertEquals(1, attribute0.ordering());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.isString());
      assertEquals(0, attribute0.type());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isDate());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isRegular());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(4, Attribute.RELATIONAL);
      assertTrue(boolean0);
      
      CfsSubsetEval cfsSubsetEval0 = new CfsSubsetEval();
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertNotNull(cfsSubsetEval0);
      
      int[] intArray0 = greedyStepwise0.search(cfsSubsetEval0, instances0);
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertTrue(greedyStepwise0.getSearchBackwards());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, instances0.numAttributes());
      assertEquals((-1), instances0.classIndex());
      assertNull(instances0.relationName());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertEquals(0, intArray0.length);
      assertNotNull(intArray0);
      assertArrayEquals(new int[] {}, intArray0);
      
      double[][] doubleArray0 = greedyStepwise0.rankedAttributes();
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertTrue(greedyStepwise0.getSearchBackwards());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals(1, doubleArray0.length);
      assertNotNull(doubleArray0);
  }

  /**
  //Test case number: 32
  /*Coverage entropy=1.3968185224533638
  */
  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertNotNull(greedyStepwise0);
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertNotNull(arrayList0);
      
      Instances instances0 = new Instances("~u8;j7JO|9YbY", arrayList0, 66);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals((-1), instances0.classIndex());
      assertEquals("~u8;j7JO|9YbY", instances0.relationName());
      assertEquals(0, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertNotNull(instances0);
      
      greedyStepwise0.m_conservativeSelection = true;
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertTrue(greedyStepwise0.getConservativeForwardSelection());
      
      Attribute attribute0 = new Attribute("@relation", 66);
      assertFalse(attribute0.isString());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0, attribute0.type());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isDate());
      assertEquals(0, attribute0.numValues());
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertTrue(attribute0.isRegular());
      assertTrue(attribute0.isAveragable());
      assertEquals("@relation", attribute0.name());
      assertFalse(attribute0.isNominal());
      assertEquals("", attribute0.getDateFormat());
      assertTrue(attribute0.isNumeric());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertTrue(attribute0.hasZeropoint());
      assertEquals(1, attribute0.ordering());
      assertFalse(attribute0.isRelationValued());
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(1, Attribute.NOMINAL);
      assertNotNull(attribute0);
      
      boolean boolean0 = arrayList0.add(attribute0);
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertFalse(attribute0.isString());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0, attribute0.type());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isDate());
      assertEquals(0, attribute0.numValues());
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertTrue(attribute0.isRegular());
      assertTrue(attribute0.isAveragable());
      assertEquals("@relation", attribute0.name());
      assertFalse(attribute0.isNominal());
      assertEquals("", attribute0.getDateFormat());
      assertTrue(attribute0.isNumeric());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertTrue(attribute0.hasZeropoint());
      assertEquals(1, attribute0.ordering());
      assertFalse(attribute0.isRelationValued());
      assertTrue(arrayList0.contains(attribute0));
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(1, Attribute.NOMINAL);
      assertTrue(boolean0);
      
      CfsSubsetEval cfsSubsetEval0 = new CfsSubsetEval();
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertNotNull(cfsSubsetEval0);
      
      String[] stringArray0 = new String[23];
      stringArray0[1] = "@end";
      stringArray0[3] = "~u8;j7JO|9YbY";
      stringArray0[4] = "numeric";
      int[] intArray0 = greedyStepwise0.search(cfsSubsetEval0, instances0);
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertTrue(greedyStepwise0.getConservativeForwardSelection());
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals((-1), instances0.classIndex());
      assertEquals("~u8;j7JO|9YbY", instances0.relationName());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertEquals(1, intArray0.length);
      assertTrue(arrayList0.contains(attribute0));
      assertNotNull(intArray0);
      assertArrayEquals(new int[] {0}, intArray0);
      
      int int0 = greedyStepwise0.m_calculatedNumToSelect;
      assertEquals(0, int0);
      
      int[] intArray1 = new int[8];
      assertFalse(intArray1.equals((Object)intArray0));
      
      intArray1[2] = 0;
      intArray1[3] = 1;
      intArray1[5] = 3;
      intArray1[7] = 0;
      greedyStepwise0.m_starting = intArray1;
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertTrue(greedyStepwise0.getConservativeForwardSelection());
      
      double[][] doubleArray0 = greedyStepwise0.rankedAttributes();
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertTrue(greedyStepwise0.getConservativeForwardSelection());
      assertEquals(1, doubleArray0.length);
      assertNotNull(doubleArray0);
  }

  /**
  //Test case number: 33
  /*Coverage entropy=1.6661022550876021
  */
  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertNotNull(greedyStepwise0);
      
      greedyStepwise0.m_backward = true;
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertTrue(greedyStepwise0.getSearchBackwards());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      
      AttributeSelectedClassifier attributeSelectedClassifier0 = new AttributeSelectedClassifier();
      assertFalse(attributeSelectedClassifier0.getDebug());
      assertEquals("Set the search method. This search method is used during the attribute selection phase before the classifier is invoked.", attributeSelectedClassifier0.searchTipText());
      assertEquals("The base classifier to be used.", attributeSelectedClassifier0.classifierTipText());
      assertEquals(0.0, attributeSelectedClassifier0.measureNumAttributesSelected(), 0.01);
      assertEquals("If set to true, classifier may output additional info to the console.", attributeSelectedClassifier0.debugTipText());
      assertEquals("Dimensionality of training and test data is reduced by attribute selection before being passed on to a classifier.", attributeSelectedClassifier0.globalInfo());
      assertEquals(0.0, attributeSelectedClassifier0.measureTime(), 0.01);
      assertEquals(0.0, attributeSelectedClassifier0.measureSelectionTime(), 0.01);
      assertEquals("Set the attribute evaluator to use. This evaluator is used during the attribute selection phase before the classifier is invoked.", attributeSelectedClassifier0.evaluatorTipText());
      assertEquals(1, attributeSelectedClassifier0.graphType());
      assertNotNull(attributeSelectedClassifier0);
      
      AttributeSelectedClassifier attributeSelectedClassifier1 = new AttributeSelectedClassifier();
      assertEquals(0.0, attributeSelectedClassifier1.measureTime(), 0.01);
      assertEquals("Set the search method. This search method is used during the attribute selection phase before the classifier is invoked.", attributeSelectedClassifier1.searchTipText());
      assertEquals("The base classifier to be used.", attributeSelectedClassifier1.classifierTipText());
      assertFalse(attributeSelectedClassifier1.getDebug());
      assertEquals("Dimensionality of training and test data is reduced by attribute selection before being passed on to a classifier.", attributeSelectedClassifier1.globalInfo());
      assertEquals(0.0, attributeSelectedClassifier1.measureNumAttributesSelected(), 0.01);
      assertEquals(1, attributeSelectedClassifier1.graphType());
      assertEquals("If set to true, classifier may output additional info to the console.", attributeSelectedClassifier1.debugTipText());
      assertEquals(0.0, attributeSelectedClassifier1.measureSelectionTime(), 0.01);
      assertEquals("Set the attribute evaluator to use. This evaluator is used during the attribute selection phase before the classifier is invoked.", attributeSelectedClassifier1.evaluatorTipText());
      assertNotNull(attributeSelectedClassifier1);
      assertFalse(attributeSelectedClassifier1.equals((Object)attributeSelectedClassifier0));
      
      CfsSubsetEval cfsSubsetEval0 = new CfsSubsetEval();
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertNotNull(cfsSubsetEval0);
      
      GreedyStepwise greedyStepwise1 = new GreedyStepwise();
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise1.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise1.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise1.globalInfo());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise1.conservativeForwardSelectionTipText());
      assertEquals((-1), greedyStepwise1.getNumToSelect());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise1.generateRankingTipText());
      assertFalse(greedyStepwise1.getConservativeForwardSelection());
      assertEquals("Search backwards rather than forwards.", greedyStepwise1.searchBackwardsTipText());
      assertFalse(greedyStepwise1.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise1.startSetTipText());
      assertFalse(greedyStepwise1.getSearchBackwards());
      assertEquals((-1.7976931348623157E308), greedyStepwise1.getThreshold(), 0.01);
      assertNotNull(greedyStepwise1);
      assertFalse(greedyStepwise1.equals((Object)greedyStepwise0));
      
      String string0 = cfsSubsetEval0.getRevision();
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertNotNull(string0);
      assertEquals("8034", string0);
      
      Attribute attribute0 = new Attribute("X");
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals("X", attribute0.name());
      assertTrue(attribute0.isNumeric());
      assertTrue(attribute0.isAveragable());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isRelationValued());
      assertEquals("", attribute0.getDateFormat());
      assertTrue(attribute0.hasZeropoint());
      assertEquals(1, attribute0.ordering());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isRegular());
      assertEquals(0, attribute0.type());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isDate());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(3, Attribute.DATE);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.STRING);
      assertNotNull(attribute0);
      
      greedyStepwise1.setNumToSelect(1);
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise1.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise1.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise1.globalInfo());
      assertEquals(1, greedyStepwise1.getNumToSelect());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise1.conservativeForwardSelectionTipText());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise1.generateRankingTipText());
      assertFalse(greedyStepwise1.getConservativeForwardSelection());
      assertEquals("Search backwards rather than forwards.", greedyStepwise1.searchBackwardsTipText());
      assertFalse(greedyStepwise1.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise1.startSetTipText());
      assertFalse(greedyStepwise1.getSearchBackwards());
      assertEquals((-1.7976931348623157E308), greedyStepwise1.getThreshold(), 0.01);
      assertNotSame(greedyStepwise1, greedyStepwise0);
      assertFalse(greedyStepwise1.equals((Object)greedyStepwise0));
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>(2);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertFalse(arrayList0.contains(attribute0));
      assertNotNull(arrayList0);
      
      boolean boolean0 = arrayList0.add(attribute0);
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals("X", attribute0.name());
      assertTrue(attribute0.isNumeric());
      assertTrue(attribute0.isAveragable());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isRelationValued());
      assertEquals("", attribute0.getDateFormat());
      assertTrue(attribute0.hasZeropoint());
      assertEquals(1, attribute0.ordering());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isRegular());
      assertEquals(0, attribute0.type());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isDate());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertTrue(arrayList0.contains(attribute0));
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(3, Attribute.DATE);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.STRING);
      assertTrue(boolean0);
      
      Instances instances0 = new Instances("relational", arrayList0, 1);
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(1, instances0.numAttributes());
      assertEquals("relational", instances0.relationName());
      assertTrue(arrayList0.contains(attribute0));
      assertNotNull(instances0);
      
      BestFirst bestFirst0 = new BestFirst();
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertNotNull(bestFirst0);
      
      Range range0 = bestFirst0.m_startRange;
      assertFalse(range0.getInvert());
      assertNotNull(range0);
      
      greedyStepwise0.m_startRange = range0;
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertTrue(greedyStepwise0.getSearchBackwards());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals(5, bestFirst0.getSearchTermination());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", bestFirst0.startSetTipText());
      assertEquals("BestFirst:\n\nSearches the space of attribute subsets by greedy hillclimbing augmented with a backtracking facility. Setting the number of consecutive non-improving nodes allowed controls the level of backtracking done. Best first may start with the empty set of attributes and search forward, or start with the full set of attributes and search backward, or start at any point and search in both directions (by considering all possible single attribute additions and deletions at a given point).\n", bestFirst0.globalInfo());
      assertEquals("Set the maximum size of the lookup cache of evaluated subsets. This is expressed as a multiplier of the number of attributes in the data set. (default = 1).", bestFirst0.lookupCacheSizeTipText());
      assertEquals("Set the amount of backtracking. Specify the number of ", bestFirst0.searchTerminationTipText());
      assertEquals(1, bestFirst0.getLookupCacheSize());
      assertEquals("Set the direction of the search.", bestFirst0.directionTipText());
      assertFalse(range0.getInvert());
      assertFalse(greedyStepwise0.m_startRange.getInvert());
      
      int[] intArray0 = greedyStepwise1.search(cfsSubsetEval0, instances0);
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise1.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise1.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise1.globalInfo());
      assertEquals(1, greedyStepwise1.getNumToSelect());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise1.conservativeForwardSelectionTipText());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise1.generateRankingTipText());
      assertFalse(greedyStepwise1.getConservativeForwardSelection());
      assertEquals("Search backwards rather than forwards.", greedyStepwise1.searchBackwardsTipText());
      assertFalse(greedyStepwise1.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise1.startSetTipText());
      assertFalse(greedyStepwise1.getSearchBackwards());
      assertEquals((-1.7976931348623157E308), greedyStepwise1.getThreshold(), 0.01);
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(1, instances0.numAttributes());
      assertEquals("relational", instances0.relationName());
      assertEquals(0, intArray0.length);
      assertTrue(arrayList0.contains(attribute0));
      assertNotNull(intArray0);
      assertNotSame(greedyStepwise1, greedyStepwise0);
      assertFalse(greedyStepwise1.equals((Object)greedyStepwise0));
      assertArrayEquals(new int[] {}, intArray0);
      
      Enumeration enumeration0 = attribute0.enumerateValues();
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals("X", attribute0.name());
      assertTrue(attribute0.isNumeric());
      assertTrue(attribute0.isAveragable());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isRelationValued());
      assertEquals("", attribute0.getDateFormat());
      assertTrue(attribute0.hasZeropoint());
      assertEquals(1, attribute0.ordering());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isRegular());
      assertEquals(0, attribute0.type());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isDate());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(3, Attribute.DATE);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.STRING);
      assertNull(enumeration0);
      
      String string1 = greedyStepwise1.toString();
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise1.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise1.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise1.globalInfo());
      assertEquals(1, greedyStepwise1.getNumToSelect());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise1.conservativeForwardSelectionTipText());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise1.generateRankingTipText());
      assertFalse(greedyStepwise1.getConservativeForwardSelection());
      assertEquals("Search backwards rather than forwards.", greedyStepwise1.searchBackwardsTipText());
      assertFalse(greedyStepwise1.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise1.startSetTipText());
      assertFalse(greedyStepwise1.getSearchBackwards());
      assertEquals((-1.7976931348623157E308), greedyStepwise1.getThreshold(), 0.01);
      assertNotNull(string1);
      assertNotSame(greedyStepwise1, greedyStepwise0);
      assertEquals("\tGreedy Stepwise (forwards).\n\tStart set: no attributes\n\tMerit of best subset found:    0    \n", string1);
      assertFalse(string1.equals((Object)string0));
      assertFalse(greedyStepwise1.equals((Object)greedyStepwise0));
      
      int[] intArray1 = bestFirst0.m_starting;
      assertNull(intArray1);
      
      Random.setNextRandom(2);
      double[][] doubleArray0 = greedyStepwise1.rankedAttributes();
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise1.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise1.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise1.globalInfo());
      assertEquals(1, greedyStepwise1.getNumToSelect());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise1.conservativeForwardSelectionTipText());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise1.generateRankingTipText());
      assertFalse(greedyStepwise1.getConservativeForwardSelection());
      assertEquals("Search backwards rather than forwards.", greedyStepwise1.searchBackwardsTipText());
      assertFalse(greedyStepwise1.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise1.startSetTipText());
      assertFalse(greedyStepwise1.getSearchBackwards());
      assertEquals((-1.7976931348623157E308), greedyStepwise1.getThreshold(), 0.01);
      assertEquals(1, doubleArray0.length);
      assertNotNull(doubleArray0);
      assertNotSame(greedyStepwise1, greedyStepwise0);
      assertFalse(greedyStepwise1.equals((Object)greedyStepwise0));
      
      try { 
        greedyStepwise0.rankedAttributes();
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // Search must be performed before attributes can be ranked.
         //
         verifyException("weka.attributeSelection.GreedyStepwise", e);
      }
  }

  /**
  //Test case number: 34
  /*Coverage entropy=1.3405220851328463
  */
  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertNotNull(greedyStepwise0);
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertNotNull(arrayList0);
      
      Instances instances0 = new Instances("~u8;j7JO|9YbY", arrayList0, 66);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertEquals("~u8;j7JO|9YbY", instances0.relationName());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals((-1), instances0.classIndex());
      assertNotNull(instances0);
      
      AttributeSelectedClassifier attributeSelectedClassifier0 = new AttributeSelectedClassifier();
      assertEquals(0.0, attributeSelectedClassifier0.measureTime(), 0.01);
      assertEquals(0.0, attributeSelectedClassifier0.measureSelectionTime(), 0.01);
      assertEquals("Set the attribute evaluator to use. This evaluator is used during the attribute selection phase before the classifier is invoked.", attributeSelectedClassifier0.evaluatorTipText());
      assertEquals(1, attributeSelectedClassifier0.graphType());
      assertEquals(0.0, attributeSelectedClassifier0.measureNumAttributesSelected(), 0.01);
      assertEquals("If set to true, classifier may output additional info to the console.", attributeSelectedClassifier0.debugTipText());
      assertEquals("Dimensionality of training and test data is reduced by attribute selection before being passed on to a classifier.", attributeSelectedClassifier0.globalInfo());
      assertFalse(attributeSelectedClassifier0.getDebug());
      assertEquals("Set the search method. This search method is used during the attribute selection phase before the classifier is invoked.", attributeSelectedClassifier0.searchTipText());
      assertEquals("The base classifier to be used.", attributeSelectedClassifier0.classifierTipText());
      assertNotNull(attributeSelectedClassifier0);
      
      greedyStepwise0.m_conservativeSelection = false;
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      
      Attribute attribute0 = new Attribute("@relation", 66);
      assertTrue(attribute0.isNumeric());
      assertEquals("@relation", attribute0.name());
      assertFalse(attribute0.isNominal());
      assertTrue(attribute0.isRegular());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(0, attribute0.type());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(0, attribute0.numValues());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.isString());
      assertEquals("", attribute0.getDateFormat());
      assertTrue(attribute0.isAveragable());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertTrue(attribute0.hasZeropoint());
      assertEquals(1, attribute0.ordering());
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.STRING);
      assertNotNull(attribute0);
      
      Attribute attribute1 = attribute0.copy("@data");
      assertTrue(attribute0.isNumeric());
      assertEquals("@relation", attribute0.name());
      assertFalse(attribute0.isNominal());
      assertTrue(attribute0.isRegular());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(0, attribute0.type());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(0, attribute0.numValues());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.isString());
      assertEquals("", attribute0.getDateFormat());
      assertTrue(attribute0.isAveragable());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertTrue(attribute0.hasZeropoint());
      assertEquals(1, attribute0.ordering());
      assertEquals(Double.POSITIVE_INFINITY, attribute1.getUpperNumericBound(), 0.01);
      assertEquals(1, attribute1.ordering());
      assertEquals(Double.NEGATIVE_INFINITY, attribute1.getLowerNumericBound(), 0.01);
      assertEquals(0, attribute1.type());
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertFalse(attribute1.isDate());
      assertEquals("@data", attribute1.name());
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertTrue(attribute1.isRegular());
      assertTrue(attribute1.hasZeropoint());
      assertTrue(attribute1.isAveragable());
      assertEquals(0, attribute1.numValues());
      assertEquals("", attribute1.getDateFormat());
      assertTrue(attribute1.isNumeric());
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertFalse(attribute1.isNominal());
      assertFalse(attribute1.isString());
      assertFalse(attribute1.isRelationValued());
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.STRING);
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(3, Attribute.DATE);
      assertEquals(4, Attribute.RELATIONAL);
      assertNotNull(attribute1);
      assertNotSame(attribute0, attribute1);
      assertNotSame(attribute1, attribute0);
      assertFalse(attribute1.equals((Object)attribute0));
      
      boolean boolean0 = arrayList0.add(attribute0);
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertTrue(attribute0.isNumeric());
      assertEquals("@relation", attribute0.name());
      assertFalse(attribute0.isNominal());
      assertTrue(attribute0.isRegular());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(0, attribute0.type());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(0, attribute0.numValues());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.isString());
      assertEquals("", attribute0.getDateFormat());
      assertTrue(attribute0.isAveragable());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertTrue(attribute0.hasZeropoint());
      assertEquals(1, attribute0.ordering());
      assertFalse(arrayList0.contains(attribute1));
      assertTrue(arrayList0.contains(attribute0));
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.STRING);
      assertNotSame(attribute0, attribute1);
      assertTrue(boolean0);
      assertFalse(attribute0.equals((Object)attribute1));
      
      CfsSubsetEval cfsSubsetEval0 = new CfsSubsetEval();
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertNotNull(cfsSubsetEval0);
      
      int[] intArray0 = greedyStepwise0.search(cfsSubsetEval0, instances0);
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertEquals("~u8;j7JO|9YbY", instances0.relationName());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals((-1), instances0.classIndex());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertEquals(0, intArray0.length);
      assertFalse(arrayList0.contains(attribute1));
      assertTrue(arrayList0.contains(attribute0));
      assertNotNull(intArray0);
      assertArrayEquals(new int[] {}, intArray0);
      
      int int0 = greedyStepwise0.m_numToSelect;
      assertEquals((-1), int0);
      
      int[] intArray1 = new int[18];
      assertFalse(intArray1.equals((Object)intArray0));
      
      intArray1[0] = 0;
      intArray1[1] = 1;
      intArray1[2] = (-1);
      intArray1[3] = 1;
      intArray1[4] = 0;
      intArray1[5] = 3;
      intArray1[6] = 20;
      intArray1[7] = 2;
      greedyStepwise0.m_starting = intArray1;
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      
      double[][] doubleArray0 = greedyStepwise0.rankedAttributes();
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertEquals(0, doubleArray0.length);
      assertNotNull(doubleArray0);
      
      int[] intArray2 = greedyStepwise0.search(cfsSubsetEval0, instances0);
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertEquals("~u8;j7JO|9YbY", instances0.relationName());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals((-1), instances0.classIndex());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertEquals(1, intArray2.length);
      assertFalse(arrayList0.contains(attribute1));
      assertTrue(arrayList0.contains(attribute0));
      assertNotNull(intArray2);
      assertNotSame(intArray2, intArray0);
      assertNotSame(intArray2, intArray1);
      assertFalse(intArray2.equals((Object)intArray0));
      assertFalse(intArray2.equals((Object)intArray1));
      assertArrayEquals(new int[] {0}, intArray2);
      
      ArrayList<Attribute> arrayList1 = new ArrayList<Attribute>();
      assertEquals(0, arrayList1.size());
      assertTrue(arrayList1.isEmpty());
      assertFalse(arrayList1.contains(attribute1));
      assertNotNull(arrayList1);
      assertFalse(arrayList1.equals((Object)arrayList0));
      
      boolean boolean1 = arrayList1.add(attribute0);
      assertTrue(attribute0.isNumeric());
      assertEquals("@relation", attribute0.name());
      assertFalse(attribute0.isNominal());
      assertTrue(attribute0.isRegular());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(0, attribute0.type());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(0, attribute0.numValues());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.isString());
      assertEquals("", attribute0.getDateFormat());
      assertTrue(attribute0.isAveragable());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertTrue(attribute0.hasZeropoint());
      assertEquals(1, attribute0.ordering());
      assertFalse(arrayList1.isEmpty());
      assertEquals(1, arrayList1.size());
      assertTrue(arrayList1.contains(attribute0));
      assertFalse(arrayList1.contains(attribute1));
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.STRING);
      assertNotSame(attribute0, attribute1);
      assertNotSame(arrayList1, arrayList0);
      assertTrue(boolean1);
      assertFalse(attribute0.equals((Object)attribute1));
      assertTrue(arrayList1.equals((Object)arrayList0));
      assertTrue(boolean1 == boolean0);
      
      double[][] doubleArray1 = greedyStepwise0.rankedAttributes();
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertEquals(0, doubleArray1.length);
      assertNotNull(doubleArray1);
      assertNotSame(doubleArray1, doubleArray0);
      assertFalse(doubleArray1.equals((Object)doubleArray0));
  }

  /**
  //Test case number: 35
  /*Coverage entropy=1.517614382310652
  */
  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      GreedyStepwise greedyStepwise0 = new GreedyStepwise();
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertNotNull(greedyStepwise0);
      
      AttributeSelectedClassifier attributeSelectedClassifier0 = new AttributeSelectedClassifier();
      assertEquals("Dimensionality of training and test data is reduced by attribute selection before being passed on to a classifier.", attributeSelectedClassifier0.globalInfo());
      assertEquals(0.0, attributeSelectedClassifier0.measureSelectionTime(), 0.01);
      assertEquals(0.0, attributeSelectedClassifier0.measureNumAttributesSelected(), 0.01);
      assertFalse(attributeSelectedClassifier0.getDebug());
      assertEquals("The base classifier to be used.", attributeSelectedClassifier0.classifierTipText());
      assertEquals("Set the search method. This search method is used during the attribute selection phase before the classifier is invoked.", attributeSelectedClassifier0.searchTipText());
      assertEquals("Set the attribute evaluator to use. This evaluator is used during the attribute selection phase before the classifier is invoked.", attributeSelectedClassifier0.evaluatorTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", attributeSelectedClassifier0.debugTipText());
      assertEquals(0.0, attributeSelectedClassifier0.measureTime(), 0.01);
      assertEquals(1, attributeSelectedClassifier0.graphType());
      assertNotNull(attributeSelectedClassifier0);
      
      AttributeSelectedClassifier attributeSelectedClassifier1 = new AttributeSelectedClassifier();
      assertEquals("Dimensionality of training and test data is reduced by attribute selection before being passed on to a classifier.", attributeSelectedClassifier1.globalInfo());
      assertEquals(0.0, attributeSelectedClassifier1.measureNumAttributesSelected(), 0.01);
      assertEquals(0.0, attributeSelectedClassifier1.measureTime(), 0.01);
      assertEquals("If set to true, classifier may output additional info to the console.", attributeSelectedClassifier1.debugTipText());
      assertEquals(1, attributeSelectedClassifier1.graphType());
      assertEquals(0.0, attributeSelectedClassifier1.measureSelectionTime(), 0.01);
      assertEquals("Set the attribute evaluator to use. This evaluator is used during the attribute selection phase before the classifier is invoked.", attributeSelectedClassifier1.evaluatorTipText());
      assertEquals("Set the search method. This search method is used during the attribute selection phase before the classifier is invoked.", attributeSelectedClassifier1.searchTipText());
      assertFalse(attributeSelectedClassifier1.getDebug());
      assertEquals("The base classifier to be used.", attributeSelectedClassifier1.classifierTipText());
      assertNotNull(attributeSelectedClassifier1);
      assertFalse(attributeSelectedClassifier1.equals((Object)attributeSelectedClassifier0));
      
      CfsSubsetEval cfsSubsetEval0 = new CfsSubsetEval();
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertNotNull(cfsSubsetEval0);
      
      GreedyStepwise greedyStepwise1 = new GreedyStepwise();
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise1.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise1.getSearchBackwards());
      assertEquals((-1.7976931348623157E308), greedyStepwise1.getThreshold(), 0.01);
      assertFalse(greedyStepwise1.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise1.startSetTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise1.numToSelectTipText());
      assertEquals((-1), greedyStepwise1.getNumToSelect());
      assertFalse(greedyStepwise1.getConservativeForwardSelection());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise1.generateRankingTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise1.thresholdTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise1.searchBackwardsTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise1.globalInfo());
      assertNotNull(greedyStepwise1);
      assertFalse(greedyStepwise1.equals((Object)greedyStepwise0));
      
      String string0 = cfsSubsetEval0.getRevision();
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertNotNull(string0);
      assertEquals("8034", string0);
      
      Attribute attribute0 = new Attribute("BI_Y6;Ut@IAB#");
      assertEquals("", attribute0.getDateFormat());
      assertEquals("BI_Y6;Ut@IAB#", attribute0.name());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertTrue(attribute0.isAveragable());
      assertTrue(attribute0.hasZeropoint());
      assertEquals(1, attribute0.ordering());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isNumeric());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isNominal());
      assertEquals(0, attribute0.type());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isDate());
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertTrue(attribute0.isRegular());
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertNotNull(attribute0);
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertFalse(arrayList0.contains(attribute0));
      assertNotNull(arrayList0);
      
      boolean boolean0 = arrayList0.add(attribute0);
      assertEquals("", attribute0.getDateFormat());
      assertEquals("BI_Y6;Ut@IAB#", attribute0.name());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertTrue(attribute0.isAveragable());
      assertTrue(attribute0.hasZeropoint());
      assertEquals(1, attribute0.ordering());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isNumeric());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isNominal());
      assertEquals(0, attribute0.type());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isDate());
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertTrue(attribute0.isRegular());
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertTrue(arrayList0.contains(attribute0));
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertTrue(boolean0);
      
      Instances instances0 = new Instances("8034", arrayList0, 1);
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals((-1), instances0.classIndex());
      assertEquals("8034", instances0.relationName());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertTrue(arrayList0.contains(attribute0));
      assertNotNull(instances0);
      
      int[] intArray0 = greedyStepwise0.search(cfsSubsetEval0, instances0);
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals((-1), instances0.classIndex());
      assertEquals("8034", instances0.relationName());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, intArray0.length);
      assertTrue(arrayList0.contains(attribute0));
      assertNotNull(intArray0);
      assertNotSame(greedyStepwise0, greedyStepwise1);
      assertFalse(greedyStepwise0.equals((Object)greedyStepwise1));
      assertArrayEquals(new int[] {}, intArray0);
      
      String string1 = greedyStepwise1.startSetToString();
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise1.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise1.getSearchBackwards());
      assertEquals((-1.7976931348623157E308), greedyStepwise1.getThreshold(), 0.01);
      assertFalse(greedyStepwise1.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise1.startSetTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise1.numToSelectTipText());
      assertEquals((-1), greedyStepwise1.getNumToSelect());
      assertFalse(greedyStepwise1.getConservativeForwardSelection());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise1.generateRankingTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise1.thresholdTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise1.searchBackwardsTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise1.globalInfo());
      assertNotNull(string1);
      assertNotSame(greedyStepwise1, greedyStepwise0);
      assertEquals("", string1);
      assertFalse(greedyStepwise1.equals((Object)greedyStepwise0));
      assertFalse(string1.equals((Object)string0));
      
      GreedyStepwise greedyStepwise2 = new GreedyStepwise();
      assertFalse(greedyStepwise2.getSearchBackwards());
      assertEquals((-1), greedyStepwise2.getNumToSelect());
      assertEquals((-1.7976931348623157E308), greedyStepwise2.getThreshold(), 0.01);
      assertFalse(greedyStepwise2.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise2.startSetTipText());
      assertFalse(greedyStepwise2.getConservativeForwardSelection());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise2.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise2.thresholdTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise2.searchBackwardsTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise2.globalInfo());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise2.generateRankingTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise2.conservativeForwardSelectionTipText());
      assertNotNull(greedyStepwise2);
      assertFalse(greedyStepwise2.equals((Object)greedyStepwise1));
      assertFalse(greedyStepwise2.equals((Object)greedyStepwise0));
      
      String string2 = greedyStepwise2.toString();
      assertFalse(greedyStepwise2.getSearchBackwards());
      assertEquals((-1), greedyStepwise2.getNumToSelect());
      assertEquals((-1.7976931348623157E308), greedyStepwise2.getThreshold(), 0.01);
      assertFalse(greedyStepwise2.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise2.startSetTipText());
      assertFalse(greedyStepwise2.getConservativeForwardSelection());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise2.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise2.thresholdTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise2.searchBackwardsTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise2.globalInfo());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise2.generateRankingTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise2.conservativeForwardSelectionTipText());
      assertNotNull(string2);
      assertNotSame(greedyStepwise2, greedyStepwise1);
      assertNotSame(greedyStepwise2, greedyStepwise0);
      assertEquals("\tGreedy Stepwise (forwards).\n\tStart set: no attributes\n\tMerit of best subset found:    0    \n", string2);
      assertFalse(greedyStepwise2.equals((Object)greedyStepwise1));
      assertFalse(greedyStepwise2.equals((Object)greedyStepwise0));
      assertFalse(string2.equals((Object)string1));
      assertFalse(string2.equals((Object)string0));
      
      UnaryOperator<Instance> unaryOperator0 = UnaryOperator.identity();
      assertNotNull(unaryOperator0);
      
      instances0.replaceAll(unaryOperator0);
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals((-1), instances0.classIndex());
      assertEquals("8034", instances0.relationName());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertTrue(arrayList0.contains(attribute0));
      
      GreedyStepwise greedyStepwise3 = new GreedyStepwise();
      assertEquals("Set to true if a ranked list is required.", greedyStepwise3.generateRankingTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise3.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise3.getSearchBackwards());
      assertFalse(greedyStepwise3.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise3.getThreshold(), 0.01);
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise3.globalInfo());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise3.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise3.thresholdTipText());
      assertEquals((-1), greedyStepwise3.getNumToSelect());
      assertFalse(greedyStepwise3.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise3.startSetTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise3.searchBackwardsTipText());
      assertNotNull(greedyStepwise3);
      assertFalse(greedyStepwise3.equals((Object)greedyStepwise0));
      assertFalse(greedyStepwise3.equals((Object)greedyStepwise2));
      assertFalse(greedyStepwise3.equals((Object)greedyStepwise1));
      
      int[] intArray1 = greedyStepwise3.search(cfsSubsetEval0, instances0);
      assertEquals("Set to true if a ranked list is required.", greedyStepwise3.generateRankingTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise3.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise3.getSearchBackwards());
      assertFalse(greedyStepwise3.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise3.getThreshold(), 0.01);
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise3.globalInfo());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise3.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise3.thresholdTipText());
      assertEquals((-1), greedyStepwise3.getNumToSelect());
      assertFalse(greedyStepwise3.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise3.startSetTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise3.searchBackwardsTipText());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals((-1), instances0.classIndex());
      assertEquals("8034", instances0.relationName());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, intArray1.length);
      assertTrue(arrayList0.contains(attribute0));
      assertNotNull(intArray1);
      assertNotSame(greedyStepwise3, greedyStepwise0);
      assertNotSame(greedyStepwise3, greedyStepwise2);
      assertNotSame(greedyStepwise3, greedyStepwise1);
      assertNotSame(intArray1, intArray0);
      assertFalse(greedyStepwise3.equals((Object)greedyStepwise0));
      assertFalse(greedyStepwise3.equals((Object)greedyStepwise2));
      assertFalse(greedyStepwise3.equals((Object)greedyStepwise1));
      assertFalse(intArray1.equals((Object)intArray0));
      assertArrayEquals(new int[] {}, intArray1);
      
      greedyStepwise2.setConservativeForwardSelection(true);
      assertFalse(greedyStepwise2.getSearchBackwards());
      assertEquals((-1), greedyStepwise2.getNumToSelect());
      assertEquals((-1.7976931348623157E308), greedyStepwise2.getThreshold(), 0.01);
      assertFalse(greedyStepwise2.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise2.startSetTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise2.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise2.thresholdTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise2.searchBackwardsTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise2.globalInfo());
      assertTrue(greedyStepwise2.getConservativeForwardSelection());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise2.generateRankingTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise2.conservativeForwardSelectionTipText());
      assertNotSame(greedyStepwise2, greedyStepwise3);
      assertNotSame(greedyStepwise2, greedyStepwise1);
      assertNotSame(greedyStepwise2, greedyStepwise0);
      assertFalse(greedyStepwise2.equals((Object)greedyStepwise3));
      assertFalse(greedyStepwise2.equals((Object)greedyStepwise1));
      assertFalse(greedyStepwise2.equals((Object)greedyStepwise0));
      
      int[] intArray2 = greedyStepwise1.search(cfsSubsetEval0, instances0);
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise1.conservativeForwardSelectionTipText());
      assertFalse(greedyStepwise1.getSearchBackwards());
      assertEquals((-1.7976931348623157E308), greedyStepwise1.getThreshold(), 0.01);
      assertFalse(greedyStepwise1.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise1.startSetTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise1.numToSelectTipText());
      assertEquals((-1), greedyStepwise1.getNumToSelect());
      assertFalse(greedyStepwise1.getConservativeForwardSelection());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise1.generateRankingTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise1.thresholdTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise1.searchBackwardsTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise1.globalInfo());
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals((-1), instances0.classIndex());
      assertEquals("8034", instances0.relationName());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, intArray2.length);
      assertTrue(arrayList0.contains(attribute0));
      assertNotNull(intArray2);
      assertNotSame(intArray2, intArray0);
      assertNotSame(intArray2, intArray1);
      assertNotSame(greedyStepwise1, greedyStepwise2);
      assertNotSame(greedyStepwise1, greedyStepwise0);
      assertNotSame(greedyStepwise1, greedyStepwise3);
      assertFalse(intArray2.equals((Object)intArray0));
      assertFalse(intArray2.equals((Object)intArray1));
      assertFalse(greedyStepwise1.equals((Object)greedyStepwise2));
      assertFalse(greedyStepwise1.equals((Object)greedyStepwise0));
      assertFalse(greedyStepwise1.equals((Object)greedyStepwise3));
      assertArrayEquals(new int[] {}, intArray2);
      
      String string3 = greedyStepwise2.startSetToString();
      assertFalse(greedyStepwise2.getSearchBackwards());
      assertEquals((-1), greedyStepwise2.getNumToSelect());
      assertEquals((-1.7976931348623157E308), greedyStepwise2.getThreshold(), 0.01);
      assertFalse(greedyStepwise2.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise2.startSetTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise2.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise2.thresholdTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise2.searchBackwardsTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise2.globalInfo());
      assertTrue(greedyStepwise2.getConservativeForwardSelection());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise2.generateRankingTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise2.conservativeForwardSelectionTipText());
      assertNotNull(string3);
      assertNotSame(greedyStepwise2, greedyStepwise3);
      assertNotSame(greedyStepwise2, greedyStepwise1);
      assertNotSame(greedyStepwise2, greedyStepwise0);
      assertEquals("", string3);
      assertTrue(string3.equals((Object)string1));
      assertFalse(string3.equals((Object)string2));
      assertFalse(string3.equals((Object)string0));
      assertFalse(greedyStepwise2.equals((Object)greedyStepwise3));
      assertFalse(greedyStepwise2.equals((Object)greedyStepwise1));
      assertFalse(greedyStepwise2.equals((Object)greedyStepwise0));
      
      int[] intArray3 = greedyStepwise2.search(cfsSubsetEval0, instances0);
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals((-1), instances0.classIndex());
      assertEquals("8034", instances0.relationName());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertFalse(greedyStepwise2.getSearchBackwards());
      assertEquals((-1), greedyStepwise2.getNumToSelect());
      assertEquals((-1.7976931348623157E308), greedyStepwise2.getThreshold(), 0.01);
      assertFalse(greedyStepwise2.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise2.startSetTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise2.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise2.thresholdTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise2.searchBackwardsTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise2.globalInfo());
      assertTrue(greedyStepwise2.getConservativeForwardSelection());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise2.generateRankingTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise2.conservativeForwardSelectionTipText());
      assertEquals(1, intArray3.length);
      assertTrue(arrayList0.contains(attribute0));
      assertNotNull(intArray3);
      assertNotSame(intArray3, intArray0);
      assertNotSame(intArray3, intArray2);
      assertNotSame(intArray3, intArray1);
      assertNotSame(greedyStepwise2, greedyStepwise3);
      assertNotSame(greedyStepwise2, greedyStepwise1);
      assertNotSame(greedyStepwise2, greedyStepwise0);
      assertFalse(intArray3.equals((Object)intArray0));
      assertFalse(intArray3.equals((Object)intArray2));
      assertFalse(intArray3.equals((Object)intArray1));
      assertFalse(greedyStepwise2.equals((Object)greedyStepwise3));
      assertFalse(greedyStepwise2.equals((Object)greedyStepwise1));
      assertFalse(greedyStepwise2.equals((Object)greedyStepwise0));
      assertArrayEquals(new int[] {0}, intArray3);
      
      Random.setNextRandom(1382);
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      assertEquals("Trim white space from each end of attribute names and nominal values before matching.", inputMappedClassifier0.trimTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", inputMappedClassifier0.debugTipText());
      assertTrue(inputMappedClassifier0.getTrim());
      assertEquals(0, inputMappedClassifier0.graphType());
      assertFalse(inputMappedClassifier0.getSuppressMappingReport());
      assertEquals("Set the path from which to load a model. Loading occurs when the first test instance is received. Environment variables can be used in the supplied path.", inputMappedClassifier0.modelPathTipText());
      assertEquals("", inputMappedClassifier0.getModelPath());
      assertEquals("Don't output a report of model-to-input mappings.", inputMappedClassifier0.suppressMappingReportTipText());
      assertTrue(inputMappedClassifier0.getIgnoreCaseForNames());
      assertFalse(inputMappedClassifier0.getDebug());
      assertEquals("The base classifier to be used.", inputMappedClassifier0.classifierTipText());
      assertEquals("Ignore case when matching attribute names and nomina values.", inputMappedClassifier0.ignoreCaseForNamesTipText());
      assertEquals("Wrapper classifier that addresses incompatible training and test data by building a mapping between the training data that a classifier has been built with and the incoming test instances' structure. Model attributes that are not found in the incoming instances receive missing values, so do incoming nominal attribute values that the classifier has not seen before. A new classifier can be trained or an existing one loaded from a file.", inputMappedClassifier0.globalInfo());
      assertNotNull(inputMappedClassifier0);
      
      Instances instances1 = inputMappedClassifier0.getModelHeader(instances0);
      assertEquals("Trim white space from each end of attribute names and nominal values before matching.", inputMappedClassifier0.trimTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", inputMappedClassifier0.debugTipText());
      assertTrue(inputMappedClassifier0.getTrim());
      assertEquals(0, inputMappedClassifier0.graphType());
      assertFalse(inputMappedClassifier0.getSuppressMappingReport());
      assertEquals("Set the path from which to load a model. Loading occurs when the first test instance is received. Environment variables can be used in the supplied path.", inputMappedClassifier0.modelPathTipText());
      assertEquals("", inputMappedClassifier0.getModelPath());
      assertEquals("Don't output a report of model-to-input mappings.", inputMappedClassifier0.suppressMappingReportTipText());
      assertTrue(inputMappedClassifier0.getIgnoreCaseForNames());
      assertFalse(inputMappedClassifier0.getDebug());
      assertEquals("The base classifier to be used.", inputMappedClassifier0.classifierTipText());
      assertEquals("Ignore case when matching attribute names and nomina values.", inputMappedClassifier0.ignoreCaseForNamesTipText());
      assertEquals("Wrapper classifier that addresses incompatible training and test data by building a mapping between the training data that a classifier has been built with and the incoming test instances' structure. Model attributes that are not found in the incoming instances receive missing values, so do incoming nominal attribute values that the classifier has not seen before. A new classifier can be trained or an existing one loaded from a file.", inputMappedClassifier0.globalInfo());
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertEquals(1, instances1.numAttributes());
      assertEquals(0, instances1.numInstances());
      assertEquals((-1), instances1.classIndex());
      assertEquals("8034", instances1.relationName());
      assertFalse(instances1.checkForStringAttributes());
      assertEquals(0.0, instances1.sumOfWeights(), 0.01);
      assertEquals(0, instances1.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals((-1), instances0.classIndex());
      assertEquals("8034", instances0.relationName());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertTrue(arrayList0.contains(attribute0));
      assertNotNull(instances1);
      assertNotSame(instances1, instances0);
      assertNotSame(instances0, instances1);
      assertTrue(instances1.equals((Object)instances0));
      
      instances1.setClass(attribute0);
      assertEquals("", attribute0.getDateFormat());
      assertEquals("BI_Y6;Ut@IAB#", attribute0.name());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertTrue(attribute0.isAveragable());
      assertTrue(attribute0.hasZeropoint());
      assertEquals(1, attribute0.ordering());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isNumeric());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isNominal());
      assertEquals(0, attribute0.type());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isDate());
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertTrue(attribute0.isRegular());
      assertEquals("Trim white space from each end of attribute names and nominal values before matching.", inputMappedClassifier0.trimTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", inputMappedClassifier0.debugTipText());
      assertTrue(inputMappedClassifier0.getTrim());
      assertEquals(0, inputMappedClassifier0.graphType());
      assertFalse(inputMappedClassifier0.getSuppressMappingReport());
      assertEquals("Set the path from which to load a model. Loading occurs when the first test instance is received. Environment variables can be used in the supplied path.", inputMappedClassifier0.modelPathTipText());
      assertEquals("", inputMappedClassifier0.getModelPath());
      assertEquals("Don't output a report of model-to-input mappings.", inputMappedClassifier0.suppressMappingReportTipText());
      assertTrue(inputMappedClassifier0.getIgnoreCaseForNames());
      assertFalse(inputMappedClassifier0.getDebug());
      assertEquals("The base classifier to be used.", inputMappedClassifier0.classifierTipText());
      assertEquals("Ignore case when matching attribute names and nomina values.", inputMappedClassifier0.ignoreCaseForNamesTipText());
      assertEquals("Wrapper classifier that addresses incompatible training and test data by building a mapping between the training data that a classifier has been built with and the incoming test instances' structure. Model attributes that are not found in the incoming instances receive missing values, so do incoming nominal attribute values that the classifier has not seen before. A new classifier can be trained or an existing one loaded from a file.", inputMappedClassifier0.globalInfo());
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertEquals(1, instances1.numAttributes());
      assertEquals(0, instances1.numInstances());
      assertEquals(0, instances1.classIndex());
      assertEquals("8034", instances1.relationName());
      assertFalse(instances1.checkForStringAttributes());
      assertEquals(1, instances1.numClasses());
      assertEquals(0.0, instances1.sumOfWeights(), 0.01);
      assertEquals(0, instances1.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals((-1), instances0.classIndex());
      assertEquals("8034", instances0.relationName());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertTrue(arrayList0.contains(attribute0));
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertNotSame(instances1, instances0);
      assertNotSame(instances0, instances1);
      assertTrue(instances1.equals((Object)instances0));
      assertTrue(instances0.equals((Object)instances1));
      
      int[] intArray4 = greedyStepwise0.search(cfsSubsetEval0, instances1);
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise0.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise0.thresholdTipText());
      assertFalse(greedyStepwise0.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise0.startSetTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise0.globalInfo());
      assertFalse(greedyStepwise0.getSearchBackwards());
      assertFalse(greedyStepwise0.getConservativeForwardSelection());
      assertEquals((-1.7976931348623157E308), greedyStepwise0.getThreshold(), 0.01);
      assertEquals("Set to true if a ranked list is required.", greedyStepwise0.generateRankingTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise0.conservativeForwardSelectionTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise0.searchBackwardsTipText());
      assertEquals((-1), greedyStepwise0.getNumToSelect());
      assertEquals("Identify locally predictive attributes. Iteratively adds attributes with the highest correlation with the class as long as there is not already an attribute in the subset that has a higher correlation with the attribute in question", cfsSubsetEval0.locallyPredictiveTipText());
      assertFalse(cfsSubsetEval0.getMissingSeparate());
      assertTrue(cfsSubsetEval0.getLocallyPredictive());
      assertEquals("Treat missing as a separate value. Otherwise, counts for missing values are distributed across other values in proportion to their frequency.", cfsSubsetEval0.missingSeparateTipText());
      assertEquals("Trim white space from each end of attribute names and nominal values before matching.", inputMappedClassifier0.trimTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", inputMappedClassifier0.debugTipText());
      assertTrue(inputMappedClassifier0.getTrim());
      assertEquals(0, inputMappedClassifier0.graphType());
      assertFalse(inputMappedClassifier0.getSuppressMappingReport());
      assertEquals("Set the path from which to load a model. Loading occurs when the first test instance is received. Environment variables can be used in the supplied path.", inputMappedClassifier0.modelPathTipText());
      assertEquals("", inputMappedClassifier0.getModelPath());
      assertEquals("Don't output a report of model-to-input mappings.", inputMappedClassifier0.suppressMappingReportTipText());
      assertTrue(inputMappedClassifier0.getIgnoreCaseForNames());
      assertFalse(inputMappedClassifier0.getDebug());
      assertEquals("The base classifier to be used.", inputMappedClassifier0.classifierTipText());
      assertEquals("Ignore case when matching attribute names and nomina values.", inputMappedClassifier0.ignoreCaseForNamesTipText());
      assertEquals("Wrapper classifier that addresses incompatible training and test data by building a mapping between the training data that a classifier has been built with and the incoming test instances' structure. Model attributes that are not found in the incoming instances receive missing values, so do incoming nominal attribute values that the classifier has not seen before. A new classifier can be trained or an existing one loaded from a file.", inputMappedClassifier0.globalInfo());
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertEquals(1, instances1.numAttributes());
      assertEquals(0, instances1.numInstances());
      assertEquals(0, instances1.classIndex());
      assertEquals("8034", instances1.relationName());
      assertFalse(instances1.checkForStringAttributes());
      assertEquals(1, instances1.numClasses());
      assertEquals(0.0, instances1.sumOfWeights(), 0.01);
      assertEquals(0, instances1.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals((-1), instances0.classIndex());
      assertEquals("8034", instances0.relationName());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, intArray4.length);
      assertTrue(arrayList0.contains(attribute0));
      assertNotNull(intArray4);
      assertNotSame(greedyStepwise0, greedyStepwise1);
      assertNotSame(greedyStepwise0, greedyStepwise2);
      assertNotSame(greedyStepwise0, greedyStepwise3);
      assertNotSame(instances1, instances0);
      assertNotSame(instances0, instances1);
      assertNotSame(intArray4, intArray0);
      assertNotSame(intArray4, intArray2);
      assertNotSame(intArray4, intArray1);
      assertNotSame(intArray4, intArray3);
      assertFalse(greedyStepwise0.equals((Object)greedyStepwise1));
      assertFalse(greedyStepwise0.equals((Object)greedyStepwise2));
      assertFalse(greedyStepwise0.equals((Object)greedyStepwise3));
      assertTrue(instances1.equals((Object)instances0));
      assertTrue(instances0.equals((Object)instances1));
      assertFalse(intArray4.equals((Object)intArray0));
      assertFalse(intArray4.equals((Object)intArray2));
      assertFalse(intArray4.equals((Object)intArray1));
      assertFalse(intArray4.equals((Object)intArray3));
      assertArrayEquals(new int[] {}, intArray4);
      
      Random.setNextRandom((-1204));
      String string4 = greedyStepwise2.startSetToString();
      assertFalse(greedyStepwise2.getSearchBackwards());
      assertEquals((-1), greedyStepwise2.getNumToSelect());
      assertEquals((-1.7976931348623157E308), greedyStepwise2.getThreshold(), 0.01);
      assertFalse(greedyStepwise2.getGenerateRanking());
      assertEquals("Set the start point for the search. This is specified as a comma seperated list off attribute indexes starting at 1. It can include ranges. Eg. 1,2,5-9,17.", greedyStepwise2.startSetTipText());
      assertEquals("Specify the number of attributes to retain. The default value (-1) indicates that all attributes are to be retained. Use either this option or a threshold to reduce the attribute set.", greedyStepwise2.numToSelectTipText());
      assertEquals("Set threshold by which attributes can be discarded. Default value results in no attributes being discarded. Use in conjunction with generateRanking", greedyStepwise2.thresholdTipText());
      assertEquals("Search backwards rather than forwards.", greedyStepwise2.searchBackwardsTipText());
      assertEquals("GreedyStepwise :\n\nPerforms a greedy forward or backward search through the space of attribute subsets. May start with no/all attributes or from an arbitrary point in the space. Stops when the addition/deletion of any remaining attributes results in a decrease in evaluation. Can also produce a ranked list of attributes by traversing the space from one side to the other and recording the order that attributes are selected.\n", greedyStepwise2.globalInfo());
      assertTrue(greedyStepwise2.getConservativeForwardSelection());
      assertEquals("Set to true if a ranked list is required.", greedyStepwise2.generateRankingTipText());
      assertEquals("If true (and forward search is selected) then attributes will continue to be added to the best subset as long as merit does not degrade.", greedyStepwise2.conservativeForwardSelectionTipText());
      assertNotNull(string4);
      assertNotSame(greedyStepwise2, greedyStepwise3);
      assertNotSame(greedyStepwise2, greedyStepwise1);
      assertNotSame(greedyStepwise2, greedyStepwise0);
      assertEquals("", string4);
      assertFalse(string4.equals((Object)string2));
      assertFalse(string4.equals((Object)string0));
      assertTrue(string4.equals((Object)string3));
      assertTrue(string4.equals((Object)string1));
      assertFalse(greedyStepwise2.equals((Object)greedyStepwise3));
      assertFalse(greedyStepwise2.equals((Object)greedyStepwise1));
      assertFalse(greedyStepwise2.equals((Object)greedyStepwise0));
  }
}
